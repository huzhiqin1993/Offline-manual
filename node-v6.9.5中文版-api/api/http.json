{
  "source": "http://nodejs.cn/api/cn/api/http.md",
  "modules": [
    {
      "textRaw": "HTTP",
      "name": "http",
      "desc": "<p>稳定性: 2 - 稳定的</p>\n<p>使用 HTTP 服务器和客户端必须 <code>require(&#39;http&#39;)</code>。</p>\n<p>Node.js 中的 HTTP 接口被设计为支持以往较难使用的协议的许多特性。\n比如，大块编码的消息。\n该接口从不缓存整个请求或响应，所以用户能够流化数据。</p>\n<p>HTTP 消息头由类似以下的对象表示：</p>\n<pre><code class=\"lang-js\">{ &#39;content-length&#39;: &#39;123&#39;,\n  &#39;content-type&#39;: &#39;text/plain&#39;,\n  &#39;connection&#39;: &#39;keep-alive&#39;,\n  &#39;host&#39;: &#39;mysite.com&#39;,\n  &#39;accept&#39;: &#39;*/*&#39; }\n</code></pre>\n<p>键名是小写的，值是不能修改的。</p>\n<p>为了支持全部可能的 HTTP 应用，Node.js 的 HTTP API 是非常底层的。\n它只涉及流处理和消息解析。\n它把一个消息解析成头部和主体，但它不解析具体的头部或主体。</p>\n<p>详见 <a href=\"#http_message_headers\"><code>message.headers</code></a> 了解如何处理重复的头部。</p>\n<p>收到的原始消息头保存在 <code>rawHeaders</code> 属性中，它是一个 <code>[key, value, key2, value2, ...]</code> 的数组。\n例如，上面的消息头对象可能有一个类似以下的 <code>rawHeaders</code> 列表：</p>\n<pre><code class=\"lang-js\">[ &#39;ConTent-Length&#39;, &#39;123456&#39;,\n  &#39;content-LENGTH&#39;, &#39;123&#39;,\n  &#39;content-type&#39;, &#39;text/plain&#39;,\n  &#39;CONNECTION&#39;, &#39;keep-alive&#39;,\n  &#39;Host&#39;, &#39;mysite.com&#39;,\n  &#39;accepT&#39;, &#39;*/*&#39; ]\n</code></pre>\n",
      "classes": [
        {
          "textRaw": "Class: http.Agent",
          "type": "class",
          "name": "http.Agent",
          "meta": {
            "added": [
              "v0.3.4"
            ]
          },
          "desc": "<p>HTTP Agent 用于池化在 HTTP 客户端请求中使用的 socket。</p>\n<p>HTTP Agent 也默认客户端请求使用 <code>Connection:keep-alive</code>。\n如果没有挂起的 HTTP 请求正在等待 socket 变成空闲的，则 socket 会被关闭。\n这意味着，当在负载状态下但仍不要求开发者使用 KeepAlive 手动关闭 HTTP 客户端时，Node.js 池有 keep-alive 的好处。</p>\n<p>如果选择使用 HTTP 的 KeepAlive，可以创建一个将标志设置为 <code>true</code> 的 Agent 对象（详见<a href=\"#http_new_agent_options\">构造器选项</a>）。\n那么，该 Agent 会保留没用过的 socket 在池中用于后续的使用。\n它们会被显式地标记，以便不用保持 Node.js 进程运行。\n当然，当它们不再被使用时，应该显式地 <a href=\"#http_agent_destroy\"><code>destroy()</code></a> KeepAlive 代理，以便 Socket 会被关闭。</p>\n<p>当 socket 触发一个 <code>&#39;close&#39;</code> 事件或一个特殊的 <code>&#39;agentRemove&#39;</code> 事件时，socket 会从代理池中被移除。\n这意味着，如果打算使一个 HTTP 请求保持长时间打开且不想让它留在池中，则可以如下操作：</p>\n<pre><code class=\"lang-js\">http.get(options, (res) =&gt; {\n  // 处理事情\n}).on(&#39;socket&#39;, (socket) =&gt; {\n  socket.emit(&#39;agentRemove&#39;);\n});\n</code></pre>\n<p>或者，可以选择使用 <code>agent:false</code> 完全地退出池：</p>\n<pre><code class=\"lang-js\">http.get({\n  hostname: &#39;localhost&#39;,\n  port: 80,\n  path: &#39;/&#39;,\n  agent: false  // 创建一个新的代理，只用于本次请求\n}, (res) =&gt; {\n  // 对响应进行处理\n});\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "agent.createConnection(options[, callback])",
              "type": "method",
              "name": "createConnection",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} 包含连接详情的选项。详见 [`net.createConnection()`] 了解选项的格式 ",
                      "name": "options",
                      "type": "Object",
                      "desc": "包含连接详情的选项。详见 [`net.createConnection()`] 了解选项的格式"
                    },
                    {
                      "textRaw": "`callback` {Function} 接收创建的 socket 的回调函数 ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "接收创建的 socket 的回调函数",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {net.Socket} ",
                      "name": "返回",
                      "type": "net.Socket"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>生产一个用于 HTTP 请求的 socket/stream。</p>\n<p>默认情况下，该函数类似于 <a href=\"net.html#net_net_createconnection_options_connectlistener\"><code>net.createConnection()</code></a>。\n但是，如果期望更大的灵活性，自定义代理可以重写此方法。</p>\n<p>socket/stream 可以由以下两个方法提供：从该函数返回 socket/stream，或传入 <code>callback</code> 的 socket/stream。</p>\n<p><code>callback</code> 有 <code>(err, stream)</code> 参数。</p>\n"
            },
            {
              "textRaw": "agent.destroy()",
              "type": "method",
              "name": "destroy",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>销毁当前正被代理使用的任何 socket。</p>\n<p>通常不需要这么做。\n但是，如果使用的是启用 KeepAlive 的代理，则当知道它不再被使用时，最好显式地关闭代理。\n否则，在服务器终止之前，socket 可能会挂起开放相当长的时间。</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "agent.getName(options)",
              "type": "method",
              "name": "getName",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} 一个提供名称生成信息的选项的集合 ",
                      "options": [
                        {
                          "textRaw": "`host` {String} 请求发送至的服务器的域名或 IP 地址 ",
                          "name": "host",
                          "type": "String",
                          "desc": "请求发送至的服务器的域名或 IP 地址"
                        },
                        {
                          "textRaw": "`port` {Number} 远程服务器的端口 ",
                          "name": "port",
                          "type": "Number",
                          "desc": "远程服务器的端口"
                        },
                        {
                          "textRaw": "`localAddress` {String} 当发送请求时，要绑定到网络连接的本地接口 ",
                          "name": "localAddress",
                          "type": "String",
                          "desc": "当发送请求时，要绑定到网络连接的本地接口"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "desc": "一个提供名称生成信息的选项的集合"
                    },
                    {
                      "textRaw": "返回: {String} ",
                      "name": "返回",
                      "type": "String"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options"
                    }
                  ]
                }
              ],
              "desc": "<p>获取请求选项集合的唯一名称，以确定连接是否可以再利用。\n在 http 代理中，这会返回 <code>host:port:localAddress</code>。\n在 https 代理中，名称会包括 CA、证书、密码和其他 HTTPS/TLS-specific 选项，以确定 socket 的可复用性。</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`freeSockets` {Object} ",
              "type": "Object",
              "name": "freeSockets",
              "meta": {
                "added": [
                  "v0.11.4"
                ]
              },
              "desc": "<p>一个包含当前正在等待被 Agent 使用的 socket 数组的对象（当使用 HTTP 的 KeepAlive 时）。\n不要修改。</p>\n"
            },
            {
              "textRaw": "`maxFreeSockets` {Number} ",
              "type": "Number",
              "name": "maxFreeSockets",
              "meta": {
                "added": [
                  "v0.11.7"
                ]
              },
              "desc": "<p>默认设为 256。\n对于支持 HTTP KeepAlive 的 Agent，它设置了在空闲状态下可打开的 socket 的最大数量。</p>\n"
            },
            {
              "textRaw": "`maxSockets` {Number} ",
              "type": "Number",
              "name": "maxSockets",
              "meta": {
                "added": [
                  "v0.3.6"
                ]
              },
              "desc": "<p>默认设为无穷大。\n决定每个来源中代理可打开多少个并发的 socket。\n来源是一个 <code>&#39;host:port&#39;</code> 或 <code>&#39;host:port:localAddress&#39;</code> 组合。</p>\n"
            },
            {
              "textRaw": "`requests` {Object} ",
              "type": "Object",
              "name": "requests",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "desc": "<p>一个包含还未被分配到 socket 的请求队列的对象。\n不要修改。</p>\n"
            },
            {
              "textRaw": "`sockets` {Object} ",
              "type": "Object",
              "name": "sockets",
              "meta": {
                "added": [
                  "v0.3.6"
                ]
              },
              "desc": "<p>一个包含当前被 Agent 使用的 socket 数组的对象。\n不要修改。</p>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} 用于设置代理的配置选项的集合。可以有以下字段： ",
                  "options": [
                    {
                      "textRaw": "`keepAlive` {Boolean} 保持池周围的 socket 在未来可被其他请求使用。默认 = `false`。 ",
                      "name": "keepAlive",
                      "type": "Boolean",
                      "desc": "保持池周围的 socket 在未来可被其他请求使用。默认 = `false`。"
                    },
                    {
                      "textRaw": "`keepAliveMsecs` {Integer} 当使用 HTTP 的 KeepAlive 时，多久发送 TCP KeepAlive 数据包使得 socket 保持活跃。 默认 = `1000`。 仅当 `keepAlive` 被设为 `true` 有效。 ",
                      "name": "keepAliveMsecs",
                      "type": "Integer",
                      "desc": "当使用 HTTP 的 KeepAlive 时，多久发送 TCP KeepAlive 数据包使得 socket 保持活跃。 默认 = `1000`。 仅当 `keepAlive` 被设为 `true` 有效。"
                    },
                    {
                      "textRaw": "`maxSockets` {Number} 每个主机允许的最大 socket 数。默认= `Infinity`。 ",
                      "name": "maxSockets",
                      "type": "Number",
                      "desc": "每个主机允许的最大 socket 数。默认= `Infinity`。"
                    },
                    {
                      "textRaw": "`maxFreeSockets` {Number} 在空闲状态下允许打开的最大 socket 数。 仅当 `keepAlive` 被设为 `true` 有效。 默认 = `256`. ",
                      "name": "maxFreeSockets",
                      "type": "Number",
                      "desc": "在空闲状态下允许打开的最大 socket 数。 仅当 `keepAlive` 被设为 `true` 有效。 默认 = `256`."
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "desc": "用于设置代理的配置选项的集合。可以有以下字段：",
                  "optional": true
                }
              ],
              "desc": "<p><a href=\"#http_http_request_options_callback\"><code>http.request()</code></a> 使用的默认的 <a href=\"#http_http_globalagent\"><code>http.globalAgent</code></a> 会将所有这些值设为各自的默认值。</p>\n<p>要配置其中任何一个，必须创建自己的 <a href=\"#http_class_http_agent\"><code>http.Agent</code></a> 对象。</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\nvar keepAliveAgent = new http.Agent({ keepAlive: true });\noptions.agent = keepAliveAgent;\nhttp.request(options, onResponseCallback);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ],
              "desc": "<p><a href=\"#http_http_request_options_callback\"><code>http.request()</code></a> 使用的默认的 <a href=\"#http_http_globalagent\"><code>http.globalAgent</code></a> 会将所有这些值设为各自的默认值。</p>\n<p>要配置其中任何一个，必须创建自己的 <a href=\"#http_class_http_agent\"><code>http.Agent</code></a> 对象。</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\nvar keepAliveAgent = new http.Agent({ keepAlive: true });\noptions.agent = keepAliveAgent;\nhttp.request(options, onResponseCallback);\n</code></pre>\n"
            }
          ]
        },
        {
          "textRaw": "Class: http.ClientRequest",
          "type": "class",
          "name": "http.ClientRequest",
          "meta": {
            "added": [
              "http://nodejs.cn/api/v0.1.17"
            ]
          },
          "desc": "<p>该对象在内部被创建，并从 <a href=\"#http_http_request_options_callback\"><code>http.request()</code></a> 返回。\n它表示着一个<strong>正在处理</strong>的请求，其请求头已进入队列。\n请求头仍可使用 <code>setHeader(name, value)</code>、<code>getHeader(name)</code> 和 <code>removeHeader(name)</code> API 进行修改。\n实际的请求头会与第一个数据块或关闭连接时一起被发送。</p>\n<p>要获取响应，需添加一个 <a href=\"#http_event_response\"><code>&#39;response&#39;</code></a> 监听器到请求对象上。\n当响应头被接收时，请求对象会触发 <a href=\"#http_event_response\"><code>&#39;response&#39;</code></a>。\n<a href=\"#http_event_response\"><code>&#39;response&#39;</code></a> 事件被执行时带有一个参数，该参数是一个 <a href=\"#http_class_http_incomingmessage\"><code>http.IncomingMessage</code></a> 实例。</p>\n<p>在 <a href=\"#http_event_response\"><code>&#39;response&#39;</code></a> 事件期间，可以添加监听器到响应对象；比如监听 <code>&#39;data&#39;</code> 事件。</p>\n<p>如果没有添加 <a href=\"#http_event_response\"><code>&#39;response&#39;</code></a> 句柄，则响应会被完全丢弃。\n当然，如果添加了 <a href=\"#http_event_response\"><code>&#39;response&#39;</code></a> 事件句柄，则<strong>必须</strong>消耗响应对象的数据（当有 <code>&#39;readable&#39;</code> 事件时调用 <code>response.read()</code>、或添加一个 <code>&#39;data&#39;</code> 句柄、或调用 <code>.resume()</code> 方法）。\n<code>&#39;end&#39;</code> 事件不会被触发，直到数据被消耗完。\n同样，在数据读完之前，它会消耗内存，可能会造成 &#39;process out of memory&#39; 错误。</p>\n<p>注意：Node.js 不会检查 Content-Length 和已发送的主体的长度是否相等。</p>\n<p>请求实现了[可写流]接口。\n这是一个包含以下事件的 <a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a>：</p>\n",
          "events": [
            {
              "textRaw": "Event: 'abort'",
              "type": "event",
              "name": "abort",
              "meta": {
                "added": [
                  "v1.4.1"
                ]
              },
              "desc": "<p>当请求已被客户端中止时触发。\n该事件仅在首次调用 <code>abort()</code> 时触发。</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'aborted'",
              "type": "event",
              "name": "aborted",
              "meta": {
                "added": [
                  "v0.3.8"
                ]
              },
              "desc": "<p>当请求已被服务器中止且网络 socket 已关闭时触发。</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "params": [],
              "desc": "<p>每当服务器响应一个带有 <code>CONNECT</code> 方法的请求时触发。\n如果该事件未被监听，则接收到 <code>CONNECT</code> 方法的客户端会关闭它们的连接。</p>\n<p>一对客户端和服务端会展示如何监听 <code>&#39;connect&#39;</code> 事件：</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\nconst net = require(&#39;net&#39;);\nconst url = require(&#39;url&#39;);\n\n// 创建一个 HTTP 通道代理\nvar proxy = http.createServer( (req, res) =&gt; {\n  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\n  res.end(&#39;okay&#39;);\n});\nproxy.on(&#39;connect&#39;, (req, cltSocket, head) =&gt; {\n  // 连接到一个来源服务器\n  var srvUrl = url.parse(`http://${req.url}`);\n  var srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () =&gt; {\n    cltSocket.write(&#39;HTTP/1.1 200 连接已建立\\r\\n&#39; +\n                    &#39;委托代理: Node.js-代理\\r\\n&#39; +\n                    &#39;\\r\\n&#39;);\n    srvSocket.write(head);\n    srvSocket.pipe(cltSocket);\n    cltSocket.pipe(srvSocket);\n  });\n});\n\n// 现在代理正在运行\nproxy.listen(1337, &#39;127.0.0.1&#39;, () =&gt; {\n\n  // 发送一个请求到通道代理\n  var options = {\n    port: 1337,\n    hostname: &#39;127.0.0.1&#39;,\n    method: &#39;CONNECT&#39;,\n    path: &#39;www.google.com:80&#39;\n  };\n\n  var req = http.request(options);\n  req.end();\n\n  req.on(&#39;connect&#39;, (res, socket, head) =&gt; {\n    console.log(&#39;got connected!&#39;);\n\n    // 发送一个请求到一个 HTTP 通道\n    socket.write(&#39;GET / HTTP/1.1\\r\\n&#39; +\n                 &#39;Host: www.google.com:80\\r\\n&#39; +\n                 &#39;Connection: close\\r\\n&#39; +\n                 &#39;\\r\\n&#39;);\n    socket.on(&#39;data&#39;, (chunk) =&gt; {\n      console.log(chunk.toString());\n    });\n    socket.on(&#39;end&#39;, () =&gt; {\n      proxy.close();\n    });\n  });\n});\n</code></pre>\n"
            },
            {
              "textRaw": "Event: 'continue'",
              "type": "event",
              "name": "continue",
              "meta": {
                "added": [
                  "v0.3.2"
                ]
              },
              "desc": "<p>当服务器发送了一个 <code>100 Continue</code> 的 HTTP 响应时触发，通常因为该请求包含 <code>Expect: 100-continue</code>。\n这是客户端应发送请求主体的指令。</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'response'",
              "type": "event",
              "name": "response",
              "meta": {
                "added": [
                  "v0.1.0"
                ]
              },
              "params": [],
              "desc": "<p>当请求的响应被接收时触发。\n该事件只触发一次。</p>\n"
            },
            {
              "textRaw": "Event: 'socket'",
              "type": "event",
              "name": "socket",
              "meta": {
                "added": [
                  "v0.5.3"
                ]
              },
              "params": [],
              "desc": "<p>当 socket 被分配给请求后触发。</p>\n"
            },
            {
              "textRaw": "Event: 'upgrade'",
              "type": "event",
              "name": "upgrade",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.94"
                ]
              },
              "params": [],
              "desc": "<p>每当服务器响应一个升级请求时触发。\n如果该事件未被监听，则接收到升级请求头的客户端会关闭它们的连接。</p>\n<p>一对客户端和服务端会展示如何监听 <code>&#39;upgrade&#39;</code> 事件：</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\n\n// 创建一个 HTTP 服务器\nvar srv = http.createServer( (req, res) =&gt; {\n  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\n  res.end(&#39;okay&#39;);\n});\nsrv.on(&#39;upgrade&#39;, (req, socket, head) =&gt; {\n  socket.write(&#39;HTTP/1.1 101 Web Socket 协议握手\\r\\n&#39; +\n               &#39;升级: WebSocket\\r\\n&#39; +\n               &#39;连接: 升级\\r\\n&#39; +\n               &#39;\\r\\n&#39;);\n\n  socket.pipe(socket); // 回声\n});\n\n// 现在服务器正在运行\nsrv.listen(1337, &#39;127.0.0.1&#39;, () =&gt; {\n\n  // 发送一个请求\n  var options = {\n    port: 1337,\n    hostname: &#39;127.0.0.1&#39;,\n    headers: {\n      &#39;Connection&#39;: &#39;Upgrade&#39;,\n      &#39;Upgrade&#39;: &#39;websocket&#39;\n    }\n  };\n\n  var req = http.request(options);\n  req.end();\n\n  req.on(&#39;upgrade&#39;, (res, socket, upgradeHead) =&gt; {\n    console.log(&#39;已升级！&#39;);\n    socket.end();\n    process.exit(0);\n  });\n});\n</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "request.abort()",
              "type": "method",
              "name": "abort",
              "meta": {
                "added": [
                  "v0.3.8"
                ]
              },
              "desc": "<p>标记请求为终止。\n调用该方法将导致响应中剩余的数据会被丢弃，且 socket 会被销毁。</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "request.end([data][, encoding][, callback])",
              "type": "method",
              "name": "end",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`data` {String | Buffer} ",
                      "name": "data",
                      "type": "String | Buffer",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} ",
                      "name": "encoding",
                      "type": "String",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>完成发送请求。\n如果主体的任何部分未被发送，则会刷新它们到流中。\n如果请求被分块，则会发送终止 <code>&#39;0\\r\\n\\r\\n&#39;</code>。</p>\n<p>如果指定了 <code>data</code>，则等同于调用 <code>request.end(callback)</code> 之后调用 <a href=\"#http_response_write_chunk_encoding_callback\"><code>response.write(data, encoding)</code></a>。</p>\n<p>如果指定了 <code>callback</code>，则当请求流结束时会被调用。</p>\n"
            },
            {
              "textRaw": "request.flushHeaders()",
              "type": "method",
              "name": "flushHeaders",
              "meta": {
                "added": [
                  "v1.6.0"
                ]
              },
              "desc": "<p>刷新请求头。</p>\n<p>出于效率的考虑，Node.js 通常缓存请求头直到调用 <code>request.end()</code> 或写入请求数据的第一块。\n然后试图将请求头和数据打包成单一的 TCP 数据包。</p>\n<p>通常那是你想要的（它节省了 TCP 往返），除了当第一个数据块直到很久之后才被发送。\n<code>request.flushHeaders()</code> 让你绕过最优化并提前开始请求。</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "request.setNoDelay([noDelay])",
              "type": "method",
              "name": "setNoDelay",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`noDelay` {Boolean} ",
                      "name": "noDelay",
                      "type": "Boolean",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "noDelay",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>一旦 socket 被分配给请求且已连接，<a href=\"net.html#net_socket_setnodelay_nodelay\"><code>socket.setNoDelay()</code></a> 会被调用。</p>\n"
            },
            {
              "textRaw": "request.setSocketKeepAlive([enable][, initialDelay])",
              "type": "method",
              "name": "setSocketKeepAlive",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`enable` {Boolean} ",
                      "name": "enable",
                      "type": "Boolean",
                      "optional": true
                    },
                    {
                      "textRaw": "`initialDelay` {Number} ",
                      "name": "initialDelay",
                      "type": "Number",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "enable",
                      "optional": true
                    },
                    {
                      "name": "initialDelay",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>一旦 socket 被分配给请求且已连接，<a href=\"net.html#net_socket_setkeepalive_enable_initialdelay\"><code>socket.setKeepAlive()</code></a> 会被调用。</p>\n"
            },
            {
              "textRaw": "request.setTimeout(timeout[, callback])",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`timeout` {Number} 一个请求被认为是超时的毫秒数。 ",
                      "name": "timeout",
                      "type": "Number",
                      "desc": "一个请求被认为是超时的毫秒数。"
                    },
                    {
                      "textRaw": "`callback` {Function} 可选的函数，当发生超时时调用。与绑定到 `timeout` 事件的相同。 ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "可选的函数，当发生超时时调用。与绑定到 `timeout` 事件的相同。",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "timeout"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>一旦 socket 被分配给请求且已连接，<a href=\"net.html#net_socket_settimeout_timeout_callback\"><code>socket.setTimeout()</code></a> 会被调用。</p>\n<p>返回 <code>request</code>。</p>\n"
            },
            {
              "textRaw": "request.write(chunk[, encoding][, callback])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.29"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`chunk` {String | Buffer} ",
                      "name": "chunk",
                      "type": "String | Buffer"
                    },
                    {
                      "textRaw": "`encoding` {String} ",
                      "name": "encoding",
                      "type": "String",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>发送主体的一个数据块。\n通过多次调用该方法，用户可以以流的形式将请求主体发送到一个服务器，在这种情况下，当创建请求时，建议使用 <code>[&#39;Transfer-Encoding&#39;, &#39;chunked&#39;]</code> 头行。</p>\n<p><code>encoding</code> 参数是可选的，且仅当 <code>chunk</code> 是一个字符串时有效。默认为 <code>&#39;utf8&#39;</code>。</p>\n<p><code>callback</code> 参数是可选的，且当数据块被刷新时调用。</p>\n<p>返回 <code>request</code>。</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: http.Server",
          "type": "class",
          "name": "http.Server",
          "meta": {
            "added": [
              "http://nodejs.cn/api/v0.1.17"
            ]
          },
          "desc": "<p>该类继承自 <a href=\"net.html#net_class_net_server\"><code>net.Server</code></a>，且具有以下额外的事件：</p>\n",
          "events": [
            {
              "textRaw": "Event: 'checkContinue'",
              "type": "event",
              "name": "checkContinue",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "params": [],
              "desc": "<p>每当接收到一个带有 HTTP <code>Expect: 100-continue</code> 的请求时触发。\n如果该事件未被监听，则服务器会自动响应 <code>100 Continue</code>。</p>\n<p>处理该事件时，如果客户端应该继续发送请求主体，则调 <a href=\"#http_response_writecontinue\"><code>response.writeContinue()</code></a>，否则生成一个适当的 HTTP 响应（例如 400 错误请求）。</p>\n<p>注意，当该事件被触发且处理后，<a href=\"#http_event_request\"><code>&#39;request&#39;</code></a> 事件不会被触发。</p>\n"
            },
            {
              "textRaw": "Event: 'checkExpectation'",
              "type": "event",
              "name": "checkExpectation",
              "meta": {
                "added": [
                  "v5.5.0"
                ]
              },
              "params": [],
              "desc": "<p>每当接收到一个带有 HTTP <code>Expect</code> 请求头的请求时触发，其中值不是 <code>100-continue</code>。\n如果该事件未被监听，则服务器会自动响应 <code>417 Expectation Failed</code>。</p>\n<p>注意，当该事件被触发且处理后，<a href=\"#http_event_request\"><code>&#39;request&#39;</code></a> 事件不会被触发。</p>\n"
            },
            {
              "textRaw": "Event: 'clientError'",
              "type": "event",
              "name": "clientError",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.94"
                ]
              },
              "params": [],
              "desc": "<p>如果一个客户端触发了一个 <code>&#39;error&#39;</code> 事件，则它会被传递到这里。\n该事件的监听器会负责关闭/销毁底层的 socket。\n例如，可能希望更温和地用一个 HTTP <code>&#39;400 Bad Request&#39;</code> 响应关闭 socket，而不是突然地切断连接。</p>\n<p>默认行为是请求异常是立即销毁 socket。</p>\n<p><code>socket</code> 是发生错误的 <a href=\"net.html#net_class_net_socket\"><code>net.Socket</code></a> 对象。</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\n\nconst server = http.createServer((req, res) =&gt; {\n  res.end();\n});\nserver.on(&#39;clientError&#39;, (err, socket) =&gt; {\n  socket.end(&#39;HTTP/1.1 400 Bad Request\\r\\n\\r\\n&#39;);\n});\nserver.listen(8000);\n</code></pre>\n<p>当 <code>&#39;clientError&#39;</code> 事件发生是，不会有 <code>request</code> 或 <code>response</code> 对象，所以发送的任何 HTTP 响应，包括响应头和内容，<strong>必须</strong>被直接写入到 <code>socket</code> 对象。\n必须小心确保响应是一个被正确格式化的 HTTP 响应消息。</p>\n"
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.4"
                ]
              },
              "desc": "<p>当服务器关闭时触发。</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "params": [],
              "desc": "<p>每当一个客户端请求一个 HTTP <code>CONNECT</code> 方法时触发。\n如果该事件未被监听，则发送 <code>CONNECT</code> 方法的客户端会关闭它们的连接。</p>\n<p>当该事件被触发后，请求的 socket 不会有 <code>&#39;data&#39;</code> 事件监听器，也就是说需要绑定它以用来处理 socket 上被发送到服务器的数据。</p>\n"
            },
            {
              "textRaw": "Event: 'connection'",
              "type": "event",
              "name": "connection",
              "meta": {
                "added": [
                  "v0.1.0"
                ]
              },
              "params": [],
              "desc": "<p>当一个新的 TCP 流被建立时触发。\n<code>socket</code> 是 <a href=\"net.html#net_class_net_socket\"><code>net.Socket</code></a> 类型的一个对象。\n通常用户无需访问此事件。\n注意，因为协议解析器绑定到 socket 上，socket 不会触发 <code>&#39;readable&#39;</code> 事件。\n<code>socket</code> 也可以通过 <code>request.connection</code> 访问。</p>\n"
            },
            {
              "textRaw": "Event: 'request'",
              "type": "event",
              "name": "request",
              "meta": {
                "added": [
                  "v0.1.0"
                ]
              },
              "params": [],
              "desc": "<p>每次接收到一个请求时触发。\n注意，每个连接可能有多个请求（在 <code>keep-alive</code> 连接的情况下）。</p>\n"
            },
            {
              "textRaw": "Event: 'upgrade'",
              "type": "event",
              "name": "upgrade",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.94"
                ]
              },
              "params": [],
              "desc": "<p>每当一个客户端请求一个 HTTP 升级时触发。\n如果该事件未被监听，则发送升级的客户端会关闭它们的连接。</p>\n<p>当该事件被触发后，请求的 socket 不会有 <code>&#39;data&#39;</code> 事件监听器，也就是说需要绑定它以用来处理 socket 上被发送到服务器的数据。</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>停止服务端接收新的连接。详见 <a href=\"net.html#net_server_close_callback\"><code>net.Server.close()</code></a>。</p>\n"
            },
            {
              "textRaw": "server.listen(handle[, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.5.10"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`handle` {Object} ",
                      "name": "handle",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "handle"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p><code>handle</code> 对象可以被设为一个服务器或 socket (任何以下划线开头的 <code>_handle</code> 成员)、或一个 <code>{fd: &lt;n&gt;}</code> 对象。</p>\n<p>这会使服务器以指定的句柄接受连接，但假定文件描述符或句柄已经被绑定到了端口或者域 socket。</p>\n<p>Windows 平台上不支持监听文件描述符。</p>\n<p>该函数是异步的。\n<code>callback</code> 会被添加到 <a href=\"net.html#net_event_listening\"><code>&#39;listening&#39;</code></a> 事件的监听器中。详见 <a href=\"net.html#net_server_listen_handle_backlog_callback\"><code>net.Server.listen()</code></a>。</p>\n<p>返回 <code>server</code>。</p>\n<p>注意，<code>server.listen()</code> 方法可能被多次调用。\n每次调用都会使用提供的选项<strong>重新打开</strong>服务器。</p>\n"
            },
            {
              "textRaw": "server.listen(path[, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`path` {String} ",
                      "name": "path",
                      "type": "String"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>启动一个 UNIX socket 服务器，并在给定的 <code>path</code> 上监听连接。</p>\n<p>该函数是异步的。\n<code>callback</code> 会被添加到 <a href=\"net.html#net_event_listening\"><code>&#39;listening&#39;</code></a> 事件的监听器中。详见 <a href=\"net.html#net_server_listen_path_backlog_callback\"><code>net.Server.listen(path)</code></a>。</p>\n<p>注意，<code>server.listen()</code> 方法可能被多次调用。\n每次调用都会使用提供的选项<strong>重新打开</strong>服务器。</p>\n"
            },
            {
              "textRaw": "server.listen([port][, hostname][, backlog][, callback])",
              "type": "method",
              "name": "listen",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`port` {Number} ",
                      "name": "port",
                      "type": "Number",
                      "optional": true
                    },
                    {
                      "textRaw": "`hostname` {String} ",
                      "name": "hostname",
                      "type": "String",
                      "optional": true
                    },
                    {
                      "textRaw": "`backlog` {Number} ",
                      "name": "backlog",
                      "type": "Number",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "port",
                      "optional": true
                    },
                    {
                      "name": "hostname",
                      "optional": true
                    },
                    {
                      "name": "backlog",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>开始在指定的 <code>port</code> 和 <code>hostname</code> 上接受连接。\n如果省略了 <code>hostname</code>，则当 IPv6 可用时，服务器会接受任何 IPv6 地址（<code>::</code>）的连接，否则接受任何 IPv4 地址（<code>0.0.0.0</code>）的连接。\n省略 <code>port</code> 参数或使用端口值 <code>0</code>，则操作系统会分配一个随机的端口，该端口可在 <code>&#39;listening&#39;</code> 事件已被触发后通过使用 <code>server.address().port</code> 获取。</p>\n<p>要监听一个 UNIX socket，需要提供文件名而不是端口和主机名。</p>\n<p><code>backlog</code> 是等待连接的队列的最大长度。\n实际长度由操作系统通过 sysctl 设置决定，比如 Linux 上的 <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code>。\n该参数的默认值是 511（不是 512）。</p>\n<p>该函数是异步的。\n<code>callback</code> 会被添加到 <a href=\"net.html#net_event_listening\"><code>&#39;listening&#39;</code></a> 事件的监听器中。详见 <a href=\"net.html#net_server_listen_port_hostname_backlog_callback\"><code>net.Server.listen(port)</code></a>。</p>\n<p>注意，<code>server.listen()</code> 方法可能被多次调用。\n每次调用都会使用提供的选项<strong>重新打开</strong>服务器。</p>\n"
            },
            {
              "textRaw": "server.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.9.12"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msecs` {Number} ",
                      "name": "msecs",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>为 socket 设置超时值。\n如果一个超时发生，则 Server 对象上会触发一个 <code>&#39;timeout&#39;</code> 事件，并传入该 socket 作为一个参数。</p>\n<p>如果 Server 对象上有 <code>&#39;timeout&#39;</code> 事件监听器，则它会被调用，并带上超时的 socket 作为一个参数。</p>\n<p>默认情况下，服务器的超时时间是 2 分钟，且超时后的 socket 会被自动销毁。\n但是，如果你为服务器的 <code>&#39;timeout&#39;</code> 事件分配了一个回调函数，则你需要负责处理 socket 的超时。</p>\n<p>返回 <code>server</code>。</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`listening` {Boolean} ",
              "type": "Boolean",
              "name": "listening",
              "meta": {
                "added": [
                  "v5.7.0"
                ]
              },
              "desc": "<p>一个表明服务器是否正在监听连接的布尔值。</p>\n"
            },
            {
              "textRaw": "`maxHeadersCount` {Number} ",
              "type": "Number",
              "name": "maxHeadersCount",
              "meta": {
                "added": [
                  "v0.7.0"
                ]
              },
              "desc": "<p>限制最大的请求头数量, 默认为 1000。\n如果设为 0，则不做任何限制。</p>\n"
            },
            {
              "textRaw": "`timeout` {Number} 默认 = 120000 (2 分钟) ",
              "type": "Number",
              "name": "timeout",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.9.12"
                ]
              },
              "desc": "<p>一个 socket 被认定为已超时的空闲毫秒数。</p>\n<p>注意，socket 的超时逻辑是在连接上设定的，所以更改这个值只影响服务器<strong>新建</strong>的连接，而不会影响任何已存在的连接。</p>\n<p>设为 0 可禁用请求连接的一切自动超时行为。</p>\n",
              "shortDesc": "默认 = 120000 (2 分钟)"
            }
          ]
        },
        {
          "textRaw": "Class: http.ServerResponse",
          "type": "class",
          "name": "http.ServerResponse",
          "meta": {
            "added": [
              "http://nodejs.cn/api/v0.1.17"
            ]
          },
          "desc": "<p>该对象是由一个 HTTP 服务器（而不是用户）内部创建的。\n它作为第二个参数被传入 <a href=\"#http_event_request\"><code>&#39;request&#39;</code></a> 事件。</p>\n<p>该响应实现（而不是继承自）[可写流]接口。\n这是一个有以下事件的 <a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a>：</p>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.6.7"
                ]
              },
              "desc": "<p>表明在 <a href=\"#http_response_end_data_encoding_callback\"><code>response.end()</code></a> 被调用或能够刷新之前，底层连接被终止了。</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'finish'",
              "type": "event",
              "name": "finish",
              "meta": {
                "added": [
                  "v0.3.6"
                ]
              },
              "desc": "<p>当响应已被发送时触发。\n更具体地说，当响应头和主体的最后一部分已被交给操作系统通过网络进行传输时，触发该事件。\n这并不意味着客户端已接收到任何东西。</p>\n<p>该事件触发后，响应对象上不再触发其他事件。</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "response.addTrailers(headers)",
              "type": "method",
              "name": "addTrailers",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`headers` {Object} ",
                      "name": "headers",
                      "type": "Object"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "headers"
                    }
                  ]
                }
              ],
              "desc": "<p>该方法会给响应添加 HTTP 追踪请求头（一个在消息尾部的请求头）。</p>\n<p>追踪<strong>仅</strong>当响应使用分块编码时才会被发送；如果不是（比如请求是 HTTP/1.0），则它们将被丢弃。</p>\n<p>注意，如果想要发送追踪，则 HTTP 要求发送 <code>Trailer</code> 请求头，且在值里带上请求头字段的列表。\n例如：</p>\n<pre><code class=\"lang-js\">response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39;,\n                          &#39;Trailer&#39;: &#39;Content-MD5&#39; });\nresponse.write(fileData);\nresponse.addTrailers({&#39;Content-MD5&#39;: &#39;7895bf4b8828b55ceaf47747b4bca667&#39;});\nresponse.end();\n</code></pre>\n<p>试图设置一个包含无效字符的请求头字段名称或值会导致抛出一个 <a href=\"errors.html#errors_class_typeerror\"><code>TypeError</code></a>。</p>\n"
            },
            {
              "textRaw": "response.end([data][, encoding][, callback])",
              "type": "method",
              "name": "end",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`data` {String | Buffer} ",
                      "name": "data",
                      "type": "String | Buffer",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} ",
                      "name": "encoding",
                      "type": "String",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>该方法告诉服务器所有响应头和主体都已被发送；服务器应将消息视为已完成。\n对于每个响应，<code>response.end()</code> 方法<strong>必须</strong>被调用。</p>\n<p>如果指定了 <code>data</code>，则它等同于调用 <a href=\"#http_response_write_chunk_encoding_callback\"><code>response.write(data, encoding)</code></a> 之后调用 <code>response.end(callback)</code>。</p>\n<p>如果指定了 <code>callback</code>，则当响应流结束时被调用。</p>\n"
            },
            {
              "textRaw": "response.getHeader(name)",
              "type": "method",
              "name": "getHeader",
              "meta": {
                "added": [
                  "v0.4.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`name` {String} ",
                      "name": "name",
                      "type": "String"
                    },
                    {
                      "textRaw": "返回: {String} ",
                      "name": "返回",
                      "type": "String"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ],
              "desc": "<p>读出已经排队但尚未发送到客户端的消息头。\n注意，名称不区分大小写。\n只能在消息头被隐式地刷新前调用。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">var contentType = response.getHeader(&#39;content-type&#39;);\n</code></pre>\n"
            },
            {
              "textRaw": "response.removeHeader(name)",
              "type": "method",
              "name": "removeHeader",
              "meta": {
                "added": [
                  "v0.4.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`name` {String} ",
                      "name": "name",
                      "type": "String"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ],
              "desc": "<p>从隐式发送的队列中移除一个消息头。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">response.removeHeader(&#39;Content-Encoding&#39;);\n</code></pre>\n"
            },
            {
              "textRaw": "response.setHeader(name, value)",
              "type": "method",
              "name": "setHeader",
              "meta": {
                "added": [
                  "v0.4.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`name` {String} ",
                      "name": "name",
                      "type": "String"
                    },
                    {
                      "textRaw": "`value` {String} ",
                      "name": "value",
                      "type": "String"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "name"
                    },
                    {
                      "name": "value"
                    }
                  ]
                }
              ],
              "desc": "<p>为隐式消息头集合设置一个的消息头值。\n如果该消息头已经存在将要发送的消息头集合中，则该值会被覆盖。\n如果需要发送多个名称相同的消息头，则使用一个字符串数组。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">response.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n</code></pre>\n<p>或</p>\n<pre><code class=\"lang-js\">response.setHeader(&#39;Set-Cookie&#39;, [&#39;type=ninja&#39;, &#39;language=javascript&#39;]);\n</code></pre>\n<p>试图设置一个包含无效字符的消息头字段名称或值会导致抛出一个 <a href=\"errors.html#errors_class_typeerror\"><code>TypeError</code></a>。</p>\n<p>当消息头已使用 <a href=\"#http_response_setheader_name_value\"><code>response.setHeader()</code></a> 设置，它们会被与其他消息头合并传给 <a href=\"#http_response_writehead_statuscode_statusmessage_headers\"><code>response.writeHead()</code></a>，带消息头的 <a href=\"#http_response_writehead_statuscode_statusmessage_headers\"><code>response.writeHead()</code></a> 有更高优先级。</p>\n<pre><code class=\"lang-js\">// 返回 content-type = text/plain\nconst server = http.createServer((req,res) =&gt; {\n  res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n  res.setHeader(&#39;X-Foo&#39;, &#39;bar&#39;);\n  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\n  res.end(&#39;ok&#39;);\n});\n</code></pre>\n"
            },
            {
              "textRaw": "response.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.9.12"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msecs` {Number} ",
                      "name": "msecs",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>设置 socket 的超时时间为 <code>msecs</code>。\n如果提供了回调函数，则它会被作为监听器添加到响应对象的 <code>&#39;timeout&#39;</code> 事件。</p>\n<p>如果没有 <code>&#39;timeout&#39;</code> 监听器被添加到请求、响应或服务器，则 socket 会在超时后被销毁。\n如果在请求、响应或服务器的 <code>&#39;timeout&#39;</code> 事件上分配了句柄，则需要负责处理超时的 socket。</p>\n<p>返回 <code>response</code>。</p>\n"
            },
            {
              "textRaw": "response.write(chunk[, encoding][, callback])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.29"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`chunk` {String | Buffer} ",
                      "name": "chunk",
                      "type": "String | Buffer"
                    },
                    {
                      "textRaw": "`encoding` {String} ",
                      "name": "encoding",
                      "type": "String",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Boolean} ",
                      "name": "返回",
                      "type": "Boolean"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>如果该方法被调用且 <a href=\"#http_response_writehead_statuscode_statusmessage_headers\"><code>response.writeHead()</code></a> 还未被调用，则它会切换到隐式消息头模式并刷新隐式消息头。</p>\n<p>它会发送一块响应主体。\n该方法可被多次调用，以便提供主体连续的部分。</p>\n<p><code>chunk</code> 可以是一个字符串或一个 buffer。\n如果 <code>chunk</code> 是一个字符串，则第二个参数指定如何将它编码成一个字节流。\n<code>encoding</code> 默认为 <code>&#39;utf8&#39;</code>。\n当数据块被刷新时，<code>callback</code> 会被调用。</p>\n<p><strong>注意</strong>：这是原始的 HTTP 主体，且与可能使用的更高级别的多部分主体编码无关。</p>\n<p><a href=\"#http_response_write_chunk_encoding_callback\"><code>response.write()</code></a> 首次被调用时，它会发送缓冲的头信息和第一块主体到客户端。\n<a href=\"#http_response_write_chunk_encoding_callback\"><code>response.write()</code></a> 第二次被调用时，Node.js 会假定你要流化数据，并将它们分别发送。\n响应会被缓冲到主体的第一个数据块。</p>\n<p>如果整个数据被成功刷新到内核缓冲区，则返回 <code>true</code>。\n如果全部或部分数据在用户内存中排队，则返回 <code>false</code>。\n当缓冲区再次空闲时，则触发 <code>&#39;drain&#39;</code> 事件。</p>\n"
            },
            {
              "textRaw": "response.writeContinue()",
              "type": "method",
              "name": "writeContinue",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p>发送一个 HTTP/1.1 100 Continue 消息到客户端，表明请求主体应该被发送。详见 <code>Server</code> 的 <a href=\"#http_event_checkcontinue\"><code>&#39;checkContinue&#39;</code></a> 事件。</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "response.writeHead(statusCode[, statusMessage][, headers])",
              "type": "method",
              "name": "writeHead",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.30"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`statusCode` {Number} ",
                      "name": "statusCode",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`statusMessage` {String} ",
                      "name": "statusMessage",
                      "type": "String",
                      "optional": true
                    },
                    {
                      "textRaw": "`headers` {Object} ",
                      "name": "headers",
                      "type": "Object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "statusCode"
                    },
                    {
                      "name": "statusMessage",
                      "optional": true
                    },
                    {
                      "name": "headers",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>发送一个响应头给请求。\n状态码是一个 3 个数字的 HTTP 状态代码，如 <code>404</code>。\n最后一个参数 <code>headers</code> 是响应头。\n第二个参数 <code>statusMessage</code> 是可选的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">var body = &#39;hello world&#39;;\nresponse.writeHead(200, {\n  &#39;Content-Length&#39;: Buffer.byteLength(body),\n  &#39;Content-Type&#39;: &#39;text/plain&#39; });\n</code></pre>\n<p>该方法在消息中只能被调用一次，且必须在 <a href=\"#http_response_end_data_encoding_callback\"><code>response.end()</code></a> 被调用之前调用。</p>\n<p>如果在调用该方法之前调用 <a href=\"#http_response_write_chunk_encoding_callback\"><code>response.write()</code></a> 或 <a href=\"#http_response_end_data_encoding_callback\"><code>response.end()</code></a>，则隐式或可变的消息头会被计算并调用该函数。</p>\n<p>当消息头已使用 <a href=\"#http_response_setheader_name_value\"><code>response.setHeader()</code></a> 设置，它们会被与其他消息头合并传给 <a href=\"#http_response_writehead_statuscode_statusmessage_headers\"><code>response.writeHead()</code></a>，带消息头的 <a href=\"#http_response_writehead_statuscode_statusmessage_headers\"><code>response.writeHead()</code></a> 有更高优先级。</p>\n<pre><code class=\"lang-js\">// 返回 content-type = text/plain\nconst server = http.createServer((req,res) =&gt; {\n  res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n  res.setHeader(&#39;X-Foo&#39;, &#39;bar&#39;);\n  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\n  res.end(&#39;ok&#39;);\n});\n</code></pre>\n<p>注意，<code>Content-Length</code> 是以字节（而不是字符）为单位给出的。\n以上的例子有效是因为字符串 <code>&#39;hello world&#39;</code> 仅包含单字节字符。\n如果主体包含更高编码的字符，则 <code>Buffer.byteLength()</code> 应被用来确定在给定编码中的字节数。\nNode.js 不会检查 <code>Content-Length</code> 与已发送的主体长度是否相同。</p>\n<p>试图设置一个包含无效字符的消息头字段名称或值会导致抛出一个 <a href=\"errors.html#errors_class_typeerror\"><code>TypeError</code></a>。</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`finished` {Boolean} ",
              "type": "Boolean",
              "name": "finished",
              "meta": {
                "added": [
                  "v0.0.2"
                ]
              },
              "desc": "<p>布尔值，表明响应是否已完成。\n开始时为 <code>false</code>。\n执行 <a href=\"#http_response_end_data_encoding_callback\"><code>response.end()</code></a> 后，该值会变为 <code>true</code>。</p>\n"
            },
            {
              "textRaw": "`headersSent` {Boolean} ",
              "type": "Boolean",
              "name": "headersSent",
              "meta": {
                "added": [
                  "v0.9.3"
                ]
              },
              "desc": "<p>布尔值（只读）。\n如果消息头已被发送则为 <code>true</code>，否则为 <code>false</code>。</p>\n"
            },
            {
              "textRaw": "`sendDate` {Boolean} ",
              "type": "Boolean",
              "name": "sendDate",
              "meta": {
                "added": [
                  "v0.7.5"
                ]
              },
              "desc": "<p>当为 <code>true</code> 时，如果消息头里还不存在日期消息头，则它会被自动生成并在响应中发送。默认为 <code>true</code>。</p>\n<p>这应该只在测试中才被禁用；HTTP 需要响应日期消息头。</p>\n"
            },
            {
              "textRaw": "`statusCode` {Number} ",
              "type": "Number",
              "name": "statusCode",
              "meta": {
                "added": [
                  "v0.4.0"
                ]
              },
              "desc": "<p>当使用隐式的消息头时（没有显式地调用 <a href=\"#http_response_writehead_statuscode_statusmessage_headers\"><code>response.writeHead()</code></a>），在消息头被刷新时该属性会控制将被发送到客户端的状态码。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">response.statusCode = 404;\n</code></pre>\n<p>响应头被发送到客户端后，该属性表明被发出的状态码。</p>\n"
            },
            {
              "textRaw": "`statusMessage` {String} ",
              "type": "String",
              "name": "statusMessage",
              "meta": {
                "added": [
                  "v0.11.8"
                ]
              },
              "desc": "<p>当使用隐式的消息头时（没有显式地调用 <a href=\"#http_response_writehead_statuscode_statusmessage_headers\"><code>response.writeHead()</code></a>），在消息头被刷新时该属性会控制将被发送到客户端的状态信息。\n如果该值为 <code>undefined</code>，则使用状态码的标准信息。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">response.statusMessage = &#39;Not found&#39;;\n</code></pre>\n<p>响应头被发送到客户端后，该属性表明被发出的状态信息。</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: http.IncomingMessage",
          "type": "class",
          "name": "http.IncomingMessage",
          "meta": {
            "added": [
              "http://nodejs.cn/api/v0.1.17"
            ]
          },
          "desc": "<p><code>IncomingMessage</code> 对象由 <a href=\"#http_class_http_server\"><code>http.Server</code></a> 或 <a href=\"#http_class_http_clientrequest\"><code>http.ClientRequest</code></a> 创建，并作为第一个参数分别递给 <a href=\"#http_event_request\"><code>&#39;request&#39;</code></a> 和 <a href=\"#http_event_response\"><code>&#39;response&#39;</code></a> 事件。\n它可以用来访问响应状态、消息头、以及数据。</p>\n<p>它实现了[可读流]接口，还有以下额外的事件、方法、以及属性。</p>\n",
          "events": [
            {
              "textRaw": "Event: 'aborted'",
              "type": "event",
              "name": "aborted",
              "meta": {
                "added": [
                  "v0.3.8"
                ]
              },
              "desc": "<p>当请求已被客户端中止且网络 socket 已关闭时触发。</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.4.2"
                ]
              },
              "desc": "<p>表明底层连接被关闭。\n就像 <code>&#39;end&#39;</code>，该事件每次响应只发生一次。</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "message.destroy([error])",
              "type": "method",
              "name": "destroy",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`error` {Error} ",
                      "name": "error",
                      "type": "Error",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "error",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>调用接收 <code>IncomingMessage</code> 的 socket 的 <code>destroy()</code>。\n如果提供了 <code>error</code>，则触发 <code>&#39;error&#39;</code> 事件，且把 <code>error</code> 作为一个参数传入事件的任何监听器。</p>\n"
            },
            {
              "textRaw": "message.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msecs` {Number} ",
                      "name": "msecs",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>调用 <code>message.connection.setTimeout(msecs, callback)</code>。</p>\n<p>返回 <code>message</code>。</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`headers` {Object} ",
              "type": "Object",
              "name": "headers",
              "meta": {
                "added": [
                  "v0.1.5"
                ]
              },
              "desc": "<p>请求/响应头的对象。</p>\n<p>报头名称和值的键值对。\n报头名称为小写。\n例如：</p>\n<pre><code class=\"lang-js\">// 输出类似以下的东西：\n//\n// { &#39;user-agent&#39;: &#39;curl/7.22.0&#39;,\n//   host: &#39;127.0.0.1:8000&#39;,\n//   accept: &#39;*/*&#39; }\nconsole.log(request.headers);\n</code></pre>\n<p>原始报头中的重复数据会按以下方式根据报头名称进行处理：</p>\n<ul>\n<li>重复的 <code>age</code> 、 <code>authorization</code> 、 <code>content-length</code> 、 <code>content-type</code> 、 \n<code>etag</code> 、 <code>expires</code> 、 <code>from</code> 、 <code>host</code> 、 <code>if-modified-since</code> 、 <code>if-unmodified-since</code> 、 \n<code>last-modified</code> 、 <code>location</code> 、 <code>max-forwards</code> 、 <code>proxy-authorization</code> 、 <code>referer</code> 、 \n<code>retry-after</code> 、或 <code>user-agent</code> 会被丢弃。</li>\n<li><code>set-cookie</code> 始终是一个数组。重复的会被添加到数组。</li>\n<li>对于所有的其他报头，其值使用 &#39;, &#39; 连接。</li>\n</ul>\n"
            },
            {
              "textRaw": "`httpVersion` {String} ",
              "type": "String",
              "name": "httpVersion",
              "meta": {
                "added": [
                  "v0.1.1"
                ]
              },
              "desc": "<p>当服务器请求时，HTTP 版本由客户端发送。\n当客户端响应时，HTTP 版本由所连接的服务器发送。\n可能的值有 <code>&#39;1.1&#39;</code> 或 <code>&#39;1.0&#39;</code>。</p>\n<p><code>message.httpVersionMajor</code> 是第一个整数，<code>message.httpVersionMinor</code> 是第二个整数。</p>\n"
            },
            {
              "textRaw": "`method` {String} ",
              "type": "String",
              "name": "method",
              "meta": {
                "added": [
                  "v0.1.1"
                ]
              },
              "desc": "<p><strong>仅适用于从 <a href=\"#http_class_http_server\"><code>http.Server</code></a> 获得的请求。</strong></p>\n<p>请求方法是一个字符串。\n只读。\n例如：<code>&#39;GET&#39;</code>、<code>&#39;DELETE&#39;</code>。</p>\n"
            },
            {
              "textRaw": "`rawHeaders` {Array} ",
              "type": "Array",
              "name": "rawHeaders",
              "meta": {
                "added": [
                  "v0.11.6"
                ]
              },
              "desc": "<p>接收到的原始请求/响应头列表。</p>\n<p>注意，键和值是在同一列表中。\n它<strong>不是</strong>一个元组列表。\n所以，偶数偏移量为键，奇数偏移量为对应的值。</p>\n<p>报头名称没有转换为小写，也没有合并去重。</p>\n<pre><code class=\"lang-js\">// 输出类似以下的东西：\n//\n// [ &#39;user-agent&#39;,\n//   &#39;this is invalid because there can be only one&#39;,\n//   &#39;User-Agent&#39;,\n//   &#39;curl/7.22.0&#39;,\n//   &#39;Host&#39;,\n//   &#39;127.0.0.1:8000&#39;,\n//   &#39;ACCEPT&#39;,\n//   &#39;*/*&#39; ]\nconsole.log(request.rawHeaders);\n</code></pre>\n"
            },
            {
              "textRaw": "`rawTrailers` {Array} ",
              "type": "Array",
              "name": "rawTrailers",
              "meta": {
                "added": [
                  "v0.11.6"
                ]
              },
              "desc": "<p>接收到的原始的请求/响应报尾的键和值。\n只在 <code>&#39;end&#39;</code> 事件时填入。</p>\n"
            },
            {
              "textRaw": "`statusCode` {Number} ",
              "type": "Number",
              "name": "statusCode",
              "meta": {
                "added": [
                  "v0.1.1"
                ]
              },
              "desc": "<p><strong>仅适用于从 <a href=\"#http_class_http_clientrequest\"><code>http.ClientRequest</code></a> 获得的响应。</strong></p>\n<p>3 位数字的 HTTP 响应状态码。\n如 <code>404</code>。</p>\n"
            },
            {
              "textRaw": "`statusMessage` {String} ",
              "type": "String",
              "name": "statusMessage",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.10"
                ]
              },
              "desc": "<p><strong>仅适用于从 <a href=\"#http_class_http_clientrequest\"><code>http.ClientRequest</code></a> 获得的响应。</strong></p>\n<p>HTTP 响应状态消息（原因描述）。如 <code>OK</code> 或 <code>Internal Server Error</code>。</p>\n"
            },
            {
              "textRaw": "`socket` {net.Socket} ",
              "type": "net.Socket",
              "name": "socket",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p>与连接有关的 <a href=\"net.html#net_class_net_socket\"><code>net.Socket</code></a> 对象。</p>\n<p>通过 HTTPS 的支持，使用 <a href=\"tls.html#tls_tlssocket_getpeercertificate_detailed\"><code>request.socket.getPeerCertificate()</code></a> 获取客户端的认证信息。</p>\n"
            },
            {
              "textRaw": "`trailers` {Object} ",
              "type": "Object",
              "name": "trailers",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "desc": "<p>请求/响应报尾对象。\n只在 <code>&#39;end&#39;</code> 事件时填入。</p>\n"
            },
            {
              "textRaw": "`url` {String} ",
              "type": "String",
              "name": "url",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "desc": "<p><strong>仅适用于从 <a href=\"#http_class_http_server\"><code>http.Server</code></a> 获得的请求。</strong></p>\n<p>请求的 URL 字符串。\n仅包含 HTTP 请求实际存在的 URL。\n如果请求是：</p>\n<pre><code class=\"lang-txt\">GET /status?name=ryan HTTP/1.1\\r\\n\nAccept: text/plain\\r\\n\n\\r\\n\n</code></pre>\n<p>则 <code>request.url</code> 会是：</p>\n<pre><code class=\"lang-js\">&#39;/status?name=ryan&#39;\n</code></pre>\n<p>如果想将 URL 解析成各个部分，可以使用 <code>require(&#39;url&#39;).parse(request.url)</code>。\n例子：</p>\n<pre><code class=\"lang-txt\">$ node\n&gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;)\n{\n  href: &#39;/status?name=ryan&#39;,\n  search: &#39;?name=ryan&#39;,\n  query: &#39;name=ryan&#39;,\n  pathname: &#39;/status&#39;\n}\n</code></pre>\n<p>如果想从查询字符串中提取参数，可以使用 <code>require(&#39;querystring&#39;).parse</code> 函数，或传入 <code>true</code> 作为 <code>require(&#39;url&#39;).parse</code> 的第二个参数。\n例子：</p>\n<pre><code class=\"lang-txt\">$ node\n&gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;, true)\n{\n  href: &#39;/status?name=ryan&#39;,\n  search: &#39;?name=ryan&#39;,\n  query: {name: &#39;ryan&#39;},\n  pathname: &#39;/status&#39;\n}\n</code></pre>\n"
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`METHODS` {Array} ",
          "type": "Array",
          "name": "METHODS",
          "meta": {
            "added": [
              "v0.11.8"
            ]
          },
          "desc": "<p>解析器支持的 HTTP 方法列表。</p>\n"
        },
        {
          "textRaw": "`STATUS_CODES` {Object} ",
          "type": "Object",
          "name": "STATUS_CODES",
          "meta": {
            "added": [
              "http://nodejs.cn/api/v0.1.22"
            ]
          },
          "desc": "<p>所有的标准 HTTP 响应状态码的集合，以及各自的简短描述。\n例如，<code>http.STATUS_CODES[404] === &#39;Not Found&#39;</code>。</p>\n"
        },
        {
          "textRaw": "`globalAgent` {http.Agent} ",
          "type": "http.Agent",
          "name": "globalAgent",
          "meta": {
            "added": [
              "v0.5.9"
            ]
          },
          "desc": "<p>Agent 的全局实例，做为所有 HTTP 客户端请求的默认 Agent。</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "http.createClient([port][, host])",
          "type": "method",
          "name": "createClient",
          "meta": {
            "added": [
              "http://nodejs.cn/api/v0.1.13"
            ],
            "deprecated": [
              "v0.3.6"
            ]
          },
          "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#http_http_request_options_callback\"><code>http.request()</code></a> 代替。</p>\n<p>Constructs a new HTTP client. <code>port</code> and <code>host</code> refer to the server to be\nconnected to.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port",
                  "optional": true
                },
                {
                  "name": "host",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.createServer([requestListener])",
          "type": "method",
          "name": "createServer",
          "meta": {
            "added": [
              "http://nodejs.cn/api/v0.1.13"
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回: {http.Server} ",
                  "name": "返回",
                  "type": "http.Server",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "requestListener",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>返回一个新建的 <a href=\"#http_class_http_server\"><code>http.Server</code></a> 实例。</p>\n<p><code>requestListener</code> 是一个会被自动添加到 <a href=\"#http_event_request\"><code>&#39;request&#39;</code></a> 事件中的函数。</p>\n"
        },
        {
          "textRaw": "http.get(options[, callback])",
          "type": "method",
          "name": "get",
          "meta": {
            "added": [
              "v0.3.6"
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} ",
                  "name": "options",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function",
                  "optional": true
                },
                {
                  "textRaw": "返回: {http.ClientRequest} ",
                  "name": "返回",
                  "type": "http.ClientRequest"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>因为大多数请求都是 GET 请求且不带主体，所以 Node.js 提供了这个便捷的方法。\n该方法与 <a href=\"#http_http_request_options_callback\"><code>http.request()</code></a> 唯一的区别是它设置请求方法为 GET 且自动调用 <code>req.end()</code>。\n注意，响应数据必须在回调中被消耗，原因详见 <a href=\"#http_class_http_clientrequest\"><code>http.ClientRequest</code></a> 章节。</p>\n<p><code>callback</code> 被调用时只有一个参数，它是 <a href=\"#http_class_http_incomingmessage\"><code>http.IncomingMessage</code></a> 的一个实例。</p>\n<p>一个获取 JSON 的例子：</p>\n<pre><code class=\"lang-js\">http.get(&#39;http://nodejs.org/dist/index.json&#39;, (res) =&gt; {\n  const statusCode = res.statusCode;\n  const contentType = res.headers[&#39;content-type&#39;];\n\n  let error;\n  if (statusCode !== 200) {\n    error = new Error(`请求失败。\\n` +\n                      `状态码: ${statusCode}`);\n  } else if (!/^application\\/json/.test(contentType)) {\n    error = new Error(`无效的 content-type.\\n` +\n                      `期望 application/json 但获取的是 ${contentType}`);\n  }\n  if (error) {\n    console.log(error.message);\n    // 消耗响应数据以释放内存\n    res.resume();\n    return;\n  }\n\n  res.setEncoding(&#39;utf8&#39;);\n  let rawData = &#39;&#39;;\n  res.on(&#39;data&#39;, (chunk) =&gt; rawData += chunk);\n  res.on(&#39;end&#39;, () =&gt; {\n    try {\n      let parsedData = JSON.parse(rawData);\n      console.log(parsedData);\n    } catch (e) {\n      console.log(e.message);\n    }\n  });\n}).on(&#39;error&#39;, (e) =&gt; {\n  console.log(`错误: ${e.message}`);\n});\n</code></pre>\n"
        },
        {
          "textRaw": "http.request(options[, callback])",
          "type": "method",
          "name": "request",
          "meta": {
            "added": [
              "v0.3.6"
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`protocol` {String} 使用的协议。默认为 `'http:'`。 ",
                      "name": "protocol",
                      "type": "String",
                      "desc": "使用的协议。默认为 `'http:'`。"
                    },
                    {
                      "textRaw": "`host` {String} 请求发送至的服务器的域名或 IP 地址。默认为 `'localhost'`。 ",
                      "name": "host",
                      "type": "String",
                      "desc": "请求发送至的服务器的域名或 IP 地址。默认为 `'localhost'`。"
                    },
                    {
                      "textRaw": "`hostname` {String} `host` 的别名。为了支持 [`url.parse()`]，`hostname` 优于 `host`。 ",
                      "name": "hostname",
                      "type": "String",
                      "desc": "`host` 的别名。为了支持 [`url.parse()`]，`hostname` 优于 `host`。"
                    },
                    {
                      "textRaw": "`family` {Number} 当解析 `host` 和 `hostname` 时使用的 IP 地址族。 有效值是 `4` 或 `6`。当未指定时，则同时使用 IP v4 和 v6。 ",
                      "name": "family",
                      "type": "Number",
                      "desc": "当解析 `host` 和 `hostname` 时使用的 IP 地址族。 有效值是 `4` 或 `6`。当未指定时，则同时使用 IP v4 和 v6。"
                    },
                    {
                      "textRaw": "`port` {Number} 远程服务器的端口。默认为 `80`。 ",
                      "name": "port",
                      "type": "Number",
                      "desc": "远程服务器的端口。默认为 `80`。"
                    },
                    {
                      "textRaw": "`localAddress` {String} 要绑定到网络连接的本地接口。 ",
                      "name": "localAddress",
                      "type": "String",
                      "desc": "要绑定到网络连接的本地接口。"
                    },
                    {
                      "textRaw": "`socketPath` {String} Unix 域 Socket（使用 host:port 或 socketPath 的其中之一）。 ",
                      "name": "socketPath",
                      "type": "String",
                      "desc": "Unix 域 Socket（使用 host:port 或 socketPath 的其中之一）。"
                    },
                    {
                      "textRaw": "`method` {String} 一个指定 HTTP 请求方法的字符串。默认为 `'GET'`。 ",
                      "name": "method",
                      "type": "String",
                      "desc": "一个指定 HTTP 请求方法的字符串。默认为 `'GET'`。"
                    },
                    {
                      "textRaw": "`path` {String} 请求的路径。默认为 `'/'`。 应包括查询字符串（如有的话）。如 `'http://nodejs.cn/index.html?page=12'`。 当请求的路径中包含非法字符时，会抛出异常。 目前只有空字符会被拒绝，但未来可能会变化。 ",
                      "name": "path",
                      "type": "String",
                      "desc": "请求的路径。默认为 `'/'`。 应包括查询字符串（如有的话）。如 `'http://nodejs.cn/index.html?page=12'`。 当请求的路径中包含非法字符时，会抛出异常。 目前只有空字符会被拒绝，但未来可能会变化。"
                    },
                    {
                      "textRaw": "`headers` {Object} 一个包含请求头的对象。 ",
                      "name": "headers",
                      "type": "Object",
                      "desc": "一个包含请求头的对象。"
                    },
                    {
                      "textRaw": "`auth` {String} 基本身份验证，如 `'user:password'` 来计算 Authorization 头。 ",
                      "name": "auth",
                      "type": "String",
                      "desc": "基本身份验证，如 `'user:password'` 来计算 Authorization 头。"
                    },
                    {
                      "textRaw": "`agent` {http.Agent|Boolean} 控制 [`Agent`] 的行为。 当使用 Agent 是，请求默认为 `Connection: keep-alive`。 可能的值有： ",
                      "options": [
                        {
                          "textRaw": "`undefined` (默认): 对该主机和端口使用 [`http.globalAgent`]。 ",
                          "name": "undefined",
                          "desc": "(默认): 对该主机和端口使用 [`http.globalAgent`]。"
                        },
                        {
                          "textRaw": "`Agent` 对象：显式地使用传入的 `Agent`。 ",
                          "name": "Agent",
                          "desc": "对象：显式地使用传入的 `Agent`。"
                        },
                        {
                          "textRaw": "`false`: 不对连接池使用 Agent，默认请求 `Connection: close`。 ",
                          "name": "false",
                          "desc": "不对连接池使用 Agent，默认请求 `Connection: close`。"
                        }
                      ],
                      "name": "agent",
                      "type": "http.Agent|Boolean",
                      "desc": "控制 [`Agent`] 的行为。 当使用 Agent 是，请求默认为 `Connection: keep-alive`。 可能的值有："
                    },
                    {
                      "textRaw": "`createConnection` {Function} 当不使用 `agent` 选项时，产生一个用于请求的 socket/stream 的函数。 这可以用于避免创建一个自定义的 Agent 类，只是为了覆盖默认的 `createConnection` 函数。详见 [`agent.createConnection()`]。 ",
                      "name": "createConnection",
                      "type": "Function",
                      "desc": "当不使用 `agent` 选项时，产生一个用于请求的 socket/stream 的函数。 这可以用于避免创建一个自定义的 Agent 类，只是为了覆盖默认的 `createConnection` 函数。详见 [`agent.createConnection()`]。"
                    },
                    {
                      "textRaw": "`timeout` {Integer}: 一个数值，指定 socket 超时的毫秒数。 它会在 socket 被连接时设置超时。 ",
                      "name": "timeout",
                      "type": "Integer",
                      "desc": ": 一个数值，指定 socket 超时的毫秒数。 它会在 socket 被连接时设置超时。"
                    }
                  ],
                  "name": "options",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function",
                  "optional": true
                },
                {
                  "textRaw": "返回: {http.ClientRequest} ",
                  "name": "返回",
                  "type": "http.ClientRequest"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Node.js 维护每台服务器的多个连接来进行 HTTP 请求。\n该函数允许显式地发出请求。</p>\n<p><code>options</code> 可以是一个对象或一个字符串。\n如果 <code>options</code> 是一个字符串，它会被自动使用 <a href=\"url.html#url_url_parse_urlstring_parsequerystring_slashesdenotehost\"><code>url.parse()</code></a> 解析。</p>\n<p>可选的 <code>callback</code> 参数会被添加为 <a href=\"#http_event_response\"><code>&#39;response&#39;</code></a> 事件的单次监听器。</p>\n<p><code>http.request()</code> 返回一个 <a href=\"#http_class_http_clientrequest\"><code>http.ClientRequest</code></a> 类的实例。\n<code>ClientRequest</code> 实例是一个可写流。\n如果需要通过 POST 请求上传一个文件，则写入到 <code>ClientRequest</code> 对象。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">var postData = querystring.stringify({\n  &#39;msg&#39; : &#39;Hello World!&#39;\n});\n\nvar options = {\n  hostname: &#39;www.google.com&#39;,\n  port: 80,\n  path: &#39;/upload&#39;,\n  method: &#39;POST&#39;,\n  headers: {\n    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,\n    &#39;Content-Length&#39;: Buffer.byteLength(postData)\n  }\n};\n\nvar req = http.request(options, (res) =&gt; {\n  console.log(`STATUS: ${res.statusCode}`);\n  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n  res.setEncoding(&#39;utf8&#39;);\n  res.on(&#39;data&#39;, (chunk) =&gt; {\n    console.log(`主体: ${chunk}`);\n  });\n  res.on(&#39;end&#39;, () =&gt; {\n    console.log(&#39;响应中已无数据。&#39;);\n  });\n});\n\nreq.on(&#39;error&#39;, (e) =&gt; {\n  console.log(`请求遇到问题: ${e.message}`);\n});\n\n// 写入数据到请求主体\nreq.write(postData);\nreq.end();\n</code></pre>\n<p>注意，在例子中调用了 <code>req.end()</code>。\n使用 <code>http.request()</code> 必须总是调用 <code>req.end()</code> 来表明请求已经结束，即使没有数据被写入请求主体。</p>\n<p>如果请求过程中遇到任何错误（DNS 解析错误、TCP 级的错误、或实际的 HTTP 解析错误），则在返回的请求对象中会触发 <code>&#39;error&#39;</code> 事件。\n对于所有的 <code>&#39;error&#39;</code> 事件，如果没有注册监听器，则抛出错误。</p>\n<p>以下是需要注意的几个特殊的请求头。</p>\n<ul>\n<li><p>发送一个 <code>&#39;Connection: keep-alive&#39;</code> 会通知 Node.js，服务器的连接应一直持续到下一个请求。</p>\n</li>\n<li><p>发送一个 <code>&#39;Content-length&#39;</code> 请求头会禁用默认的块编码。</p>\n</li>\n<li><p>发送一个 <code>&#39;Expect&#39;</code> 请求头会立即发送请求头。\n通常情况下，当发送 <code>&#39;Expect: 100-continue&#39;</code> 时，应该设置一个超时并监听 <code>&#39;continue&#39;</code> 事件。\n详见 RFC2616 章节 8.2.3。</p>\n</li>\n<li><p>发送一个 Authorization 请求头会覆盖使用 <code>auth</code> 选项计算基本身份验证。</p>\n</li>\n</ul>\n"
        }
      ],
      "type": "module",
      "displayName": "HTTP"
    }
  ]
}