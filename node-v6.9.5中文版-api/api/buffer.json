{
  "source": "http://nodejs.cn/api/cn/api/buffer.md",
  "modules": [
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "desc": "<p>稳定性: 2 - 稳定的</p>\n<p>在 ECMAScript 2015 (ES6) 引入 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> 之前，JavaScript 语言没有读取或操作二进制数据流的机制。\n<code>Buffer</code> 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流和文件系统操作等场景中处理二进制数据流。</p>\n<p>现在 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> 已经被添加进 ES6 中，<code>Buffer</code> 类以一种更优与更适合 Node.js 用例的方式实现了 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> API。</p>\n<p><code>Buffer</code> 类的实例类似于整数数组，除了其是大小固定的、且在 V8 堆外分配物理内存。\n<code>Buffer</code> 的大小在其创建时就已确定，且不能调整大小。</p>\n<p><code>Buffer</code> 类在 Node.js 中是一个全局变量，因此无需 <code>require(&#39;buffer&#39;).Buffer</code>。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">// 创建一个长度为 10、且用 0 填充的 Buffer。\nconst buf1 = Buffer.alloc(10);\n\n// 创建一个长度为 10、且用 0x1 填充的 Buffer。 \nconst buf2 = Buffer.alloc(10, 1);\n\n// 创建一个长度为 10、且未初始化的 Buffer。\n// 这个方法比调用 Buffer.alloc() 更快，\n// 但返回的 Buffer 实例可能包含旧数据，\n// 因此需要使用 fill() 或 write() 重写。\nconst buf3 = Buffer.allocUnsafe(10);\n\n// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// 创建一个包含 ASCII 字节数组 [0x74, 0x65, 0x73, 0x74] 的 Buffer。\nconst buf5 = Buffer.from(&#39;test&#39;);\n\n// 创建一个包含 UTF-8 字节数组 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。\nconst buf6 = Buffer.from(&#39;tést&#39;, &#39;utf8&#39;);\n</code></pre>\n",
      "modules": [
        {
          "textRaw": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`",
          "name": "`buffer.from()`,_`buffer.alloc()`,_and_`buffer.allocunsafe()`",
          "desc": "<p>在 Node.js v6 之前的版本中，<code>Buffer</code> 实例是通过 <code>Buffer</code> 构造函数创建的，它根据提供的参数返回不同的 <code>Buffer</code>：</p>\n<ul>\n<li>传一个数值作为第一个参数给 <code>Buffer()</code>（如 <code>new Buffer(10)</code>），则分配一个指定大小的新建的 <code>Buffer</code> 对象。\n分配给这种 <code>Buffer</code> 实例的内存是<strong>没有</strong>初始化的，且<strong>可能包含敏感数据</strong>。\n这种 <code>Buffer</code> 实例<strong>必须手动地</strong>被初始化，可以使用 <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> 或写满这个 <code>Buffer</code>。\n虽然这种行为是为了提高性能而<strong>有意为之的</strong>，但开发经验表明，创建一个快速但未初始化的 <code>Buffer</code> 与创建一个慢点但更安全的 <code>Buffer</code> 之间需要有更明确的区分。</li>\n<li>传一个字符串、数组、或 <code>Buffer</code> 作为第一个参数，则将所传对象的数据拷贝到 <code>Buffer</code> 中。</li>\n<li>传入一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>，则返回一个与给定的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> 共享所分配内存的 <code>Buffer</code>。</li>\n</ul>\n<p>因为 <code>new Buffer()</code> 的行为会根据所传入的第一个参数的值的数据类型而明显地改变，所以如果应用程序没有正确地校验传给 <code>new Buffer()</code> 的参数、或未能正确地初始化新分配的 <code>Buffer</code> 的内容，就有可能在无意中为他们的代码引入安全性与可靠性问题。</p>\n<p>为了使 <code>Buffer</code> 实例的创建更可靠、更不容易出错，各种 <code>new Buffer()</code> 构造函数已被 <strong>废弃</strong>，并由 <code>Buffer.from()</code>、<a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a>、和 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 方法替代。</p>\n<p><strong>开发者们应当把所有正在使用的 <code>new Buffer()</code> 构造函数迁移到这些新的 API 上。</strong></p>\n<ul>\n<li><a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a> 返回一个新建的包含所提供的字节数组的副本的 <code>Buffer</code>。</li>\n<li><a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a> 返回一个新建的与给定的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> 共享同一内存的 <code>Buffer</code>。</li>\n<li><a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a> 返回一个新建的包含所提供的 <code>Buffer</code> 的内容的副本的 <code>Buffer</code>。</li>\n<li><a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> 返回一个新建的包含所提供的字符串的副本的 <code>Buffer</code>。</li>\n<li><a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> 返回一个指定大小的被填满的 <code>Buffer</code> 实例。\n这个方法会明显地比 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe(size)</code></a> 慢，但可确保新创建的 <code>Buffer</code> 实例绝不会包含旧的和潜在的敏感数据。</li>\n<li><a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe(size)</code></a> 与 <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow(size)</code></a> 返回一个新建的指定 <code>size</code> 的 <code>Buffer</code>，但它的内容<strong>必须</strong>被初始化，可以使用 <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> 或完全写满。</li>\n</ul>\n<p>如果 <code>size</code> 小于或等于 <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> 的一半，则 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 返回的 <code>Buffer</code> 实例<strong>可能</strong>会被分配进一个共享的内部内存池。</p>\n",
          "modules": [
            {
              "textRaw": "The `--zero-fill-buffers` command line option",
              "name": "the_`--zero-fill-buffers`_command_line_option",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "desc": "<p>Node.js 可以在一开始就使用 <code>--zero-fill-buffers</code> 命令行选项强制所有使用 <code>new Buffer(size)</code> 、<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 、<a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a> 或 <code>new SlowBuffer(size)</code> 新分配的 <code>Buffer</code> 实例在创建时<strong>自动用 0 填充</strong>。\n使用这个选项会<strong>改变</strong>这些方法的<strong>默认行为</strong>，且<strong>对性能有明显的影响</strong>。\n建议只在需要强制新分配的 <code>Buffer</code> 实例不能包含潜在的敏感数据时才使用 <code>--zero-fill-buffers</code> 选项。</p>\n<p>例子：</p>\n<pre><code class=\"lang-txt\">$ node --zero-fill-buffers\n&gt; Buffer.allocUnsafe(5);\n&lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n",
              "type": "module",
              "displayName": "The `--zero-fill-buffers` command line option"
            },
            {
              "textRaw": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?",
              "name": "what_makes_`buffer.allocunsafe()`_and_`buffer.allocunsafeslow()`_\"unsafe\"?",
              "desc": "<p>当调用 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 和 <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a> 时，被分配的内存段是<strong>未初始化的</strong>（没有用 0 填充）。\n虽然这样的设计使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感旧数据。\n使用通过 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 创建的没有被<strong>完全</strong>重写内存的 <code>Buffer</code> ，在 <code>Buffer</code> 内存可读的情况下，可能泄露它的旧数据。</p>\n<p>虽然使用 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 有明显的性能优势，但必须额外<strong>小心</strong>，以避免给应用程序引入安全漏洞。</p>\n",
              "type": "module",
              "displayName": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?"
            }
          ],
          "type": "module",
          "displayName": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`"
        },
        {
          "textRaw": "Buffers and Character Encodings",
          "name": "buffers_and_character_encodings",
          "desc": "<p><code>Buffer</code> 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。\n通过使用显式的字符编码，就可以在 <code>Buffer</code> 实例与普通的 JavaScript 字符串之间进行相互转换。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;hello world&#39;, &#39;ascii&#39;);\n\n// 输出 68656c6c6f20776f726c64\nconsole.log(buf.toString(&#39;hex&#39;));\n\n// 输出 aGVsbG8gd29ybGQ=\nconsole.log(buf.toString(&#39;base64&#39;));\n</code></pre>\n<p>Node.js 目前支持的字符编码包括：</p>\n<ul>\n<li><p><code>&#39;ascii&#39;</code> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</p>\n</li>\n<li><p><code>&#39;utf8&#39;</code> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</p>\n</li>\n<li><p><code>&#39;utf16le&#39;</code> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</p>\n</li>\n<li><p><code>&#39;ucs2&#39;</code> - <code>&#39;utf16le&#39;</code> 的别名。</p>\n</li>\n<li><p><code>&#39;base64&#39;</code> - Base64 编码。当从字符串创建 <code>Buffer</code> 时，按照 <a href=\"https://tools.ietf.org/html/rfc4648#section-5\">RFC4648 第 5 章</a>的规定，这种编码也将正确地接受“URL 与文件名安全字母表”。</p>\n</li>\n<li><p><code>&#39;latin1&#39;</code> - 一种把 <code>Buffer</code> 编码成一字节编码的字符串的方式（由 IANA 定义在 <a href=\"https://tools.ietf.org/html/rfc1345\">RFC1345</a> 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）。</p>\n</li>\n<li><p><code>&#39;binary&#39;</code> - <code>&#39;latin1&#39;</code> 的别名。</p>\n</li>\n<li><p><code>&#39;hex&#39;</code> - 将每个字节编码为两个十六进制字符。</p>\n</li>\n</ul>\n<p><strong>注意</strong>：现代浏览器遵循 <a href=\"https://encoding.spec.whatwg.org/\">WHATWG 规范</a> 将 &#39;latin1&#39; 和 ISO-8859-1 别名为 win-1252。\n这意味着当进行例如 <code>http.get()</code> 这样的操作时，如果返回的字符编码是 WHATWG 规范列表中的，则有可能服务器真的返回 win-1252 编码的数据，此时使用 <code>&#39;latin1&#39;</code> 字符编码可能会错误地解码数据。</p>\n",
          "type": "module",
          "displayName": "Buffers and Character Encodings"
        },
        {
          "textRaw": "Buffers and TypedArray",
          "name": "buffers_and_typedarray",
          "desc": "<p><code>Buffer</code> 实例也是 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> 实例。\n但是与 ECMAScript 2015 中的 TypedArray 规范还是有些微妙的不同。\n例如，当 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice\"><code>ArrayBuffer#slice()</code></a> 创建一个切片的副本时，<a href=\"#buffer_buf_slice_start_end\"><code>Buffer#slice()</code></a> 的实现是在现有的 <code>Buffer</code> 上不经过拷贝直接进行创建，这也使得 <a href=\"#buffer_buf_slice_start_end\"><code>Buffer#slice()</code></a> 更高效。</p>\n<p>遵循以下注意事项，也可以从一个 <code>Buffer</code> 创建一个新的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> 实例：</p>\n<ol>\n<li><p><code>Buffer</code> 对象的内存是拷贝到 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> 的，而不是共享的。</p>\n</li>\n<li><p><code>Buffer</code> 对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组。\n也就是说，<code>new Uint32Array(Buffer.from([1, 2, 3, 4]))</code> 会创建一个包含 <code>[1, 2, 3, 4]</code> 四个元素的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array\"><code>Uint32Array</code></a>，而不是一个只包含一个元素 <code>[0x1020304]</code> 或 <code>[0x4030201]</code> 的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array\"><code>Uint32Array</code></a> 。</p>\n</li>\n</ol>\n<p>也可以通过 TypeArray 对象的 <code>.buffer</code> 属性创建一个新建的且与 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> 实例共享同一分配内存的 <code>Buffer</code> 。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// 拷贝 `arr` 的内容\nconst buf1 = Buffer.from(arr);\n\n// 与 `arr` 共享内存\nconst buf2 = Buffer.from(arr.buffer);\n\n// 输出: &lt;Buffer 88 a0&gt;\nconsole.log(buf1);\n\n// 输出: &lt;Buffer 88 13 a0 0f&gt;\nconsole.log(buf2);\n\narr[1] = 6000;\n\n// 输出: &lt;Buffer 88 a0&gt;\nconsole.log(buf1);\n\n// 输出: &lt;Buffer 88 13 70 17&gt;\nconsole.log(buf2);\n</code></pre>\n<p>注意，当使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> 的 <code>.buffer</code> 创建 <code>Buffer</code> 时，也可以通过传入 <code>byteOffset</code> 和 <code>length</code> 参数只使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> 的一部分。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(20);\nconst buf = Buffer.from(arr.buffer, 0, 16);\n\n// 输出: 16\nconsole.log(buf.length);\n</code></pre>\n<p><code>Buffer.from()</code> 和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from\"><code>TypedArray.from()</code></a> 有着不同的签名与实现。\n具体而言，<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> 的变种接受第二个参数，在类型数组的每个元素上调用一次映射函数：</p>\n<ul>\n<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>\n</ul>\n<p><code>Buffer.from()</code> 方法不支持使用映射函数：</p>\n<ul>\n<li><a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a></li>\n</ul>\n",
          "type": "module",
          "displayName": "Buffers and TypedArray"
        },
        {
          "textRaw": "Buffers and ES6 iteration",
          "name": "buffers_and_es6_iteration",
          "desc": "<p><code>Buffer</code> 实例可以使用 ECMAScript 2015 (ES6) 的 <code>for..of</code> 语法进行遍历。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3]);\n\n// 输出:\n//   1\n//   2\n//   3\nfor (var b of buf) {\n  console.log(b);\n}\n</code></pre>\n<p>此外，<a href=\"#buffer_buf_values\"><code>buf.values()</code></a> 、<a href=\"#buffer_buf_keys\"><code>buf.keys()</code></a> 和 <a href=\"#buffer_buf_entries\"><code>buf.entries()</code></a> 方法可用于创建迭代器。</p>\n",
          "type": "module",
          "displayName": "Buffers and ES6 iteration"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Buffer",
          "type": "class",
          "name": "Buffer",
          "desc": "<p><code>Buffer</code> 类是一个全局变量类型，用来直接处理二进制数据的。\n它能够使用多种方式构建。</p>\n",
          "classMethods": [
            {
              "textRaw": "Class Method: Buffer.alloc(size[, fill[, encoding]])",
              "type": "classMethod",
              "name": "alloc",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Integer} 新建的 `Buffer` 期望的长度 ",
                      "name": "size",
                      "type": "Integer",
                      "desc": "新建的 `Buffer` 期望的长度"
                    },
                    {
                      "textRaw": "`fill` {String | Buffer | Integer} 用来预填充新建的 `Buffer` 的值。 **默认:** `0` ",
                      "name": "fill",
                      "type": "String | Buffer | Integer",
                      "desc": "用来预填充新建的 `Buffer` 的值。 **默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} 如果 `fill` 是字符串，则该值是它的字符编码。 **默认:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "如果 `fill` 是字符串，则该值是它的字符编码。 **默认:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    },
                    {
                      "name": "fill",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>分配一个大小为 <code>size</code> 字节的新建的 <code>Buffer</code> 。\n如果 <code>fill</code> 为 <code>undefined</code> ，则该 <code>Buffer</code> 会用 <strong>0 填充</strong>。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(5);\n\n// 输出: &lt;Buffer 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n<p><code>size</code> 必须小于或等于 <a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> 的值，否则会抛出 <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> 错误。\n如果 <code>size</code> 小于或等于0，则创建一个长度为0的 <code>Buffer</code> 。</p>\n<p>如果指定了 <code>fill</code> ，则会调用 <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(fill)</code></a> 初始化分配的 <code>Buffer</code> 。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(5, &#39;a&#39;);\n\n// 输出: &lt;Buffer 61 61 61 61 61&gt;\nconsole.log(buf);\n</code></pre>\n<p>如果同时指定了 <code>fill</code> 和 <code>encoding</code> ，则会调用 <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(fill, encoding)</code></a> 初始化分配的 <code>Buffer</code> 。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(11, &#39;aGVsbG8gd29ybGQ=&#39;, &#39;base64&#39;);\n\n// 输出: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;\nconsole.log(buf);\n</code></pre>\n<p>调用 <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> 会明显地比另一个方法 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 慢，但是能确保新建的 <code>Buffer</code> 实例的内容<strong>不会包含敏感数据</strong>。</p>\n<p>如果 <code>size</code> 不是一个数值，则抛出 <code>TypeError</code> 错误。</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafe(size)",
              "type": "classMethod",
              "name": "allocUnsafe",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Integer} 新建的 `Buffer` 期望的长度 ",
                      "name": "size",
                      "type": "Integer",
                      "desc": "新建的 `Buffer` 期望的长度"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ],
              "desc": "<p>分配一个大小为 <code>size</code> 字节的新建的<strong>没有用0填充</strong>的 <code>Buffer</code> 。\n<code>size</code> 必须小于或等于 <a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> 的值，否则将抛出 <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> 错误。\n如果 <code>size</code> 小于或等于0，则创建一个长度为0的 <code>Buffer</code> 。</p>\n<p>以这种方式创建的 <code>Buffer</code> 实例的底层内存是<strong>未初始化</strong>的。\n新创建的 <code>Buffer</code> 的内容是未知的，且<strong>可能包含敏感数据</strong>。\n可以使用 <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> 初始化 <code>Buffer</code> 实例为0。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(5);\n\n// 输出: (内容可能不同): &lt;Buffer 78 e0 82 02 01&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// 输出: &lt;Buffer 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n<p>如果 <code>size</code> 不是一个数值，则抛出 <code>TypeError</code> 错误。</p>\n<p>注意，<code>Buffer</code> 模块会预分配一个大小为 <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> 的内部 <code>Buffer</code> 实例作为快速分配池，\n用于使用 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 新创建的 <code>Buffer</code> 实例，以及废弃的 <code>new Buffer(size)</code> 构造器，\n仅限于当 <code>size</code> 小于或等于 <code>Buffer.poolSize &gt;&gt; 1</code> （<a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> 除以2后的最大整数值）。</p>\n<p>对这个预分配的内部内存池的使用，是调用 <code>Buffer.alloc(size, fill)</code> 和 <code>Buffer.allocUnsafe(size).fill(fill)</code> 的关键区别。\n具体地说，如果 <code>size</code> 小于或等于 <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> 的一半，则 <code>Buffer.alloc(size, fill)</code> <strong>不会</strong>使用这个内部的 <code>Buffer</code> 池，而 <code>Buffer.allocUnsafe(size).fill(fill)</code> <strong>会</strong>使用这个内部的 <code>Buffer</code> 池。\n当应用程序需要 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 提供额外的性能时，这个细微的区别是非常重要的。</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafeSlow(size)",
              "type": "classMethod",
              "name": "allocUnsafeSlow",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Integer} 新建的 `Buffer` 期望的长度 ",
                      "name": "size",
                      "type": "Integer",
                      "desc": "新建的 `Buffer` 期望的长度"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ],
              "desc": "<p>分配一个大小为 <code>size</code> 字节的新建的<strong>没有用0填充</strong>的非池 <code>Buffer</code> 。\n<code>size</code> 必须小于或等于 <a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> 的值，否则将抛出 <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> 错误。\n如果 <code>size</code> 小于或等于0，则创建一个长度为0的 <code>Buffer</code> 。</p>\n<p>以这种方式创建的 <code>Buffer</code> 实例的底层内存是<strong>未初始化</strong>的。\n新创建的 <code>Buffer</code> 的内容是未知的，且<strong>可能包含敏感数据</strong>。\n可以使用 <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> 初始化 <code>Buffer</code> 实例为0。</p>\n<p>当使用 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> 分配新建的 <code>Buffer</code> 时，当分配的内存小于 4KB 时，默认会从一个单一的预分配的 <code>Buffer</code> 切割出来。\n这使得应用程序可以避免垃圾回收机制因创建太多独立分配的 <code>Buffer</code> 实例而过度使用。\n这个方法通过像大多数持久对象一样消除追踪与清理的需求，改善了性能与内存使用。</p>\n<p>当然，在开发者可能需要在不确定的时间段从内存池保留一小块内存的情况下，使用 <code>Buffer.allocUnsafeSlow()</code> 创建一个非池的 <code>Buffer</code> 实例然后拷贝出相关的位元是合适的做法。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">// 需要保留一小块内存块\nconst store = [];\n\nsocket.on(&#39;readable&#39;, () =&gt; {\n  const data = socket.read();\n\n  // 为保留的数据分配内存\n  const sb = Buffer.allocUnsafeSlow(10);\n\n  // 拷贝数据进新分配的内存\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n</code></pre>\n<p><code>Buffer.allocUnsafeSlow()</code> 应当仅仅作为开发者已经在他们的应用程序中观察到过度的内存保留之后的终极手段使用。</p>\n<p>如果 <code>size</code> 不是一个数值，则抛出 <code>TypeError</code> 错误。</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.byteLength(string[, encoding])",
              "type": "classMethod",
              "name": "byteLength",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`string` {String | Buffer | TypedArray | DataView | ArrayBuffer} 要计算长度的值 ",
                      "name": "string",
                      "type": "String | Buffer | TypedArray | DataView | ArrayBuffer",
                      "desc": "要计算长度的值"
                    },
                    {
                      "textRaw": "`encoding` {String} 如果 `string` 是字符串，则这是它的字符编码。 **默认:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "如果 `string` 是字符串，则这是它的字符编码。 **默认:** `'utf8'`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `string` 包含的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`string` 包含的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>返回一个字符串的实际字节长度。\n这与 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length\"><code>String.prototype.length</code></a> 不同，因为那返回字符串的<strong>字符</strong>数。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const str = &#39;\\u00bd + \\u00bc = \\u00be&#39;;\n\n// 输出: ½ + ¼ = ¾: 9 个字符, 12 个字节\nconsole.log(`${str}: ${str.length} 个字符, ` +\n            `${Buffer.byteLength(str, &#39;utf8&#39;)} 个字节`);\n</code></pre>\n<p>当 <code>string</code> 是一个 <code>Buffer</code>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\"><code>DataView</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> 时，返回实际的字节长度。</p>\n<p>否则，会转换为 <code>String</code> 并返回字符串的字节长度。</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.compare(buf1, buf2)",
              "type": "classMethod",
              "name": "compare",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.13"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`buf1` {Buffer} ",
                      "name": "buf1",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`buf2` {Buffer} ",
                      "name": "buf2",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf1"
                    },
                    {
                      "name": "buf2"
                    }
                  ]
                }
              ],
              "desc": "<p>比较 <code>buf1</code> 和 <code>buf2</code> ，通常用于 <code>Buffer</code> 实例数组的排序。\n相当于调用 <a href=\"#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend\"><code>buf1.compare(buf2)</code></a> 。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;1234&#39;);\nconst buf2 = Buffer.from(&#39;0123&#39;);\nconst arr = [buf1, buf2];\n\n// 输出: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]\n// (结果相当于: [buf2, buf1])\nconsole.log(arr.sort(Buffer.compare));\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.concat(list[, totalLength])",
              "type": "classMethod",
              "name": "concat",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.7.11"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`list` {Array} 要合并的 `Buffer` 实例的数组 ",
                      "name": "list",
                      "type": "Array",
                      "desc": "要合并的 `Buffer` 实例的数组"
                    },
                    {
                      "textRaw": "`totalLength` {Integer} 合并时 `list` 中 `Buffer` 实例的总长度 ",
                      "name": "totalLength",
                      "type": "Integer",
                      "desc": "合并时 `list` 中 `Buffer` 实例的总长度",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Buffer} ",
                      "name": "返回",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "list"
                    },
                    {
                      "name": "totalLength",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>返回一个合并了 <code>list</code> 中所有 <code>Buffer</code> 实例的新建的 <code>Buffer</code> 。</p>\n<p>如果 <code>list</code> 中没有元素、或 <code>totalLength</code> 为 0 ，则返回一个新建的长度为 0 的 <code>Buffer</code> 。</p>\n<p>如果没有提供 <code>totalLength</code> ，则从 <code>list</code> 中的 <code>Buffer</code> 实例计算得到。\n为了计算 <code>totalLength</code> 会导致需要执行额外的循环，所以提供明确的长度会运行更快。</p>\n<p>例子：从一个包含三个 <code>Buffer</code> 实例的数组创建为一个单一的 <code>Buffer</code>。</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.alloc(10);\nconst buf2 = Buffer.alloc(14);\nconst buf3 = Buffer.alloc(18);\nconst totalLength = buf1.length + buf2.length + buf3.length;\n\n// 输出: 42\nconsole.log(totalLength);\n\nconst bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\n\n// 输出: &lt;Buffer 00 00 00 00 ...&gt;\nconsole.log(bufA);\n\n// 输出: 42\nconsole.log(bufA.length);\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(array)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`array` {Array} ",
                      "name": "array",
                      "type": "Array"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "array"
                    }
                  ]
                }
              ],
              "desc": "<p>通过一个八位字节的 <code>array</code> 创建一个新的 <code>Buffer</code> 。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">// 创建一个新的包含字符串 &#39;buffer&#39; 的 ASCII 字节的 Buffer\nconst buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n<p>如果 <code>array</code> 不是一个数组，则抛出 <code>TypeError</code> 错误。</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`arrayBuffer` {ArrayBuffer} [`TypedArray`] 或 [`ArrayBuffer`] 的 `.buffer` 属性 ",
                      "name": "arrayBuffer",
                      "type": "ArrayBuffer",
                      "desc": "[`TypedArray`] 或 [`ArrayBuffer`] 的 `.buffer` 属性"
                    },
                    {
                      "textRaw": "`byteOffset` {Integer} 从 `arrayBuffer` 开始拷贝的位置。 **默认:** `0` ",
                      "name": "byteOffset",
                      "type": "Integer",
                      "desc": "从 `arrayBuffer` 开始拷贝的位置。 **默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {Integer} 从 `arrayBuffer` 拷贝多少字节。 **默认:** `arrayBuffer.length - byteOffset` ",
                      "name": "length",
                      "type": "Integer",
                      "desc": "从 `arrayBuffer` 拷贝多少字节。 **默认:** `arrayBuffer.length - byteOffset`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "arrayBuffer"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>当传入一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> 实例的 <code>.buffer</code> 属性的引用时，这个新建的 <code>Buffer</code> 会像 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> 那样共享同一分配的内存。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// 与 `arr` 共享内存\nconst buf = Buffer.from(arr.buffer);\n\n// 输出: &lt;Buffer 88 13 a0 0f&gt;\nconsole.log(buf);\n\n// 改变原始的 Uint16Array 也会改变 Buffer\narr[1] = 6000;\n\n// 输出: &lt;Buffer 88 13 70 17&gt;\nconsole.log(buf);\n</code></pre>\n<p>可选的 <code>byteOffset</code> 和 <code>length</code> 参数指定将与 <code>Buffer</code> 共享的 <code>arrayBuffer</code> 的内存范围。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const ab = new ArrayBuffer(10);\nconst buf = Buffer.from(ab, 0, 2);\n\n// 输出: 2\nconsole.log(buf.length);\n</code></pre>\n<p>如果 <code>arrayBuffer</code> 不是一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>，则抛出 <code>TypeError</code> 错误。</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(buffer)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`buffer` {Buffer} 一个要拷贝数据的已存在的 `Buffer` ",
                      "name": "buffer",
                      "type": "Buffer",
                      "desc": "一个要拷贝数据的已存在的 `Buffer`"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ],
              "desc": "<p>将传入的 <code>buffer</code> 数据拷贝到一个新建的 <code>Buffer</code> 实例。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;buffer&#39;);\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61;\n\n// 输出: auffer\nconsole.log(buf1.toString());\n\n// 输出: buffer\nconsole.log(buf2.toString());\n</code></pre>\n<p>如果 <code>buffer</code> 不是一个 <code>Buffer</code>，则抛出 <code>TypeError</code> 错误。</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(string[, encoding])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`string` {String} 要编码的字符串 ",
                      "name": "string",
                      "type": "String",
                      "desc": "要编码的字符串"
                    },
                    {
                      "textRaw": "`encoding` {String} `string` 的字符编码。 **默认:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "`string` 的字符编码。 **默认:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>新建一个包含所给的 JavaScript 字符串 <code>string</code> 的 <code>Buffer</code> 。\n<code>encoding</code> 参数指定 <code>string</code> 的字符编码。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;this is a tést&#39;);\n\n// 输出: this is a tést\nconsole.log(buf1.toString());\n\n// 输出: this is a tC)st\nconsole.log(buf1.toString(&#39;ascii&#39;));\n\n\nconst buf2 = Buffer.from(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\n\n// 输出: this is a tést\nconsole.log(buf2.toString());\n</code></pre>\n<p>如果 <code>string</code> 不是一个字符串，则抛出 <code>TypeError</code> 错误。</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.isBuffer(obj)",
              "type": "classMethod",
              "name": "isBuffer",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.101"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`obj` {Object} ",
                      "name": "obj",
                      "type": "Object"
                    },
                    {
                      "textRaw": "返回: {Boolean} ",
                      "name": "返回",
                      "type": "Boolean"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "obj"
                    }
                  ]
                }
              ],
              "desc": "<p>如果 <code>obj</code> 是一个 <code>Buffer</code> 则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.isEncoding(encoding)",
              "type": "classMethod",
              "name": "isEncoding",
              "meta": {
                "added": [
                  "v0.9.1"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`encoding` {String} 一个要检查的字符编码名称 ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "一个要检查的字符编码名称"
                    },
                    {
                      "textRaw": "返回: {Boolean} ",
                      "name": "返回",
                      "type": "Boolean"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ],
              "desc": "<p>如果 <code>encoding</code> 是一个支持的字符编码则返回 <code>true</code>，否则返回 <code>false</code> 。</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`poolSize` {Integer} **默认:** `8192` ",
              "type": "Integer",
              "name": "poolSize",
              "meta": {
                "added": [
                  "v0.11.3"
                ]
              },
              "desc": "<p>这是用于决定预分配的、内部 <code>Buffer</code> 实例池的大小的字节数。\n这个值可以修改。</p>\n",
              "shortDesc": "**默认:** `8192`"
            },
            {
              "textRaw": "buf[index]",
              "name": "[index]",
              "meta": {
                "type": "property",
                "name": [
                  "index"
                ]
              },
              "desc": "<p>索引操作符 <code>[index]</code> 可用于获取或设置 <code>buf</code> 中指定 <code>index</code> 位置的八位字节。\n这个值指向的是单个字节，所以合法的值范围是的 <code>0x00</code> 至 <code>0xFF</code>（十六进制），或 <code>0</code> 至 <code>255</code>（十进制）。</p>\n<p>例如：拷贝一个 ASCII 字符串到一个 <code>Buffer</code>，每次一个字节。</p>\n<pre><code class=\"lang-js\">const str = &#39;Node.js&#39;;\nconst buf = Buffer.allocUnsafe(str.length);\n\nfor (let i = 0; i &lt; str.length ; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\n// 输出: Node.js\nconsole.log(buf.toString(&#39;ascii&#39;));\n</code></pre>\n"
            },
            {
              "textRaw": "`length` {Integer} ",
              "type": "Integer",
              "name": "length",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "desc": "<p>返回 <code>buf</code> 在字节数上分配的内存量。\n注意，这并不一定反映 <code>buf</code> 内可用的数据量。</p>\n<p>例子：创建一个 <code>Buffer</code> 并写入一个较短的 ASCII 字符串。</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(1234);\n\n// 输出: 1234\nconsole.log(buf.length);\n\nbuf.write(&#39;some string&#39;, 0, &#39;ascii&#39;);\n\n// 输出: 1234\nconsole.log(buf.length);\n</code></pre>\n<p>虽然 <code>length</code> 属性不是不可变的，但改变 <code>length</code> 的值可能会导致不确定、不一致的行为。\n那些希望修改一个 <code>Buffer</code> 的长度的应用程序应当将 <code>length</code> 视为只读的，且使用 <a href=\"#buffer_buf_slice_start_end\"><code>buf.slice()</code></a> 创建一个新的 <code>Buffer</code>。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">var buf = Buffer.allocUnsafe(10);\n\nbuf.write(&#39;abcdefghj&#39;, 0, &#39;ascii&#39;);\n\n// 输出: 10\nconsole.log(buf.length);\n\nbuf = buf.slice(0, 5);\n\n// 输出: 5\nconsole.log(buf.length);\n</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])",
              "type": "method",
              "name": "compare",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.13"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`target` {Buffer} 要比较的 `Buffer` ",
                      "name": "target",
                      "type": "Buffer",
                      "desc": "要比较的 `Buffer`"
                    },
                    {
                      "textRaw": "`targetStart` {Integer} `target` 中开始对比的偏移量。 **默认:** `0` ",
                      "name": "targetStart",
                      "type": "Integer",
                      "desc": "`target` 中开始对比的偏移量。 **默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`targetEnd` {Integer} `target` 中结束对比的偏移量（不包含）。 当 `targetStart` 为 `undefined` 时忽略。 **默认:** `target.length` ",
                      "name": "targetEnd",
                      "type": "Integer",
                      "desc": "`target` 中结束对比的偏移量（不包含）。 当 `targetStart` 为 `undefined` 时忽略。 **默认:** `target.length`",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` {Integer} `buf` 中开始对比的偏移量。 当 `targetStart` 为 `undefined` 时忽略。 **默认:** `0` ",
                      "name": "sourceStart",
                      "type": "Integer",
                      "desc": "`buf` 中开始对比的偏移量。 当 `targetStart` 为 `undefined` 时忽略。 **默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` {Integer} `buf` 中结束对比的偏移量（不包含）。 当 `targetStart` 为 `undefined` 时忽略。 **默认:** [`buf.length`] ",
                      "name": "sourceEnd",
                      "type": "Integer",
                      "desc": "`buf` 中结束对比的偏移量（不包含）。 当 `targetStart` 为 `undefined` 时忽略。 **默认:** [`buf.length`]",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "target"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "targetEnd",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>比较 <code>buf</code> 与 <code>target</code>，返回表明 <code>buf</code> 在排序上是否排在 <code>target</code> 之前、或之后、或相同。\n对比是基于各自 <code>Buffer</code> 实际的字节序列。</p>\n<ul>\n<li>如果 <code>target</code> 与 <code>buf</code> 相同，则返回 <code>0</code> 。</li>\n<li>如果 <code>target</code> 排在 <code>buf</code> <strong>前面</strong>，则返回 <code>1</code> 。</li>\n<li>如果 <code>target</code> 排在 <code>buf</code> <strong>后面</strong>，则返回 <code>-1</code> 。</li>\n</ul>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;ABC&#39;);\nconst buf2 = Buffer.from(&#39;BCD&#39;);\nconst buf3 = Buffer.from(&#39;ABCD&#39;);\n\n// 输出: 0\nconsole.log(buf1.compare(buf1));\n\n// 输出: -1\nconsole.log(buf1.compare(buf2));\n\n// 输出: -1\nconsole.log(buf1.compare(buf3));\n\n// 输出: 1\nconsole.log(buf2.compare(buf1));\n\n// 输出: 1\nconsole.log(buf2.compare(buf3));\n\n// 输出: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]\n// (结果相当于: [buf1, buf3, buf2])\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n</code></pre>\n<p>可选的  <code>targetStart</code> 、 <code>targetEnd</code> 、 <code>sourceStart</code> 与 <code>sourceEnd</code> 参数可用于分别在 <code>target</code> 与 <code>buf</code> 中限制对比在指定的范围内。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\n// 输出: 0\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n\n// 输出: -1\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n\n// 输出: 1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n</code></pre>\n<p>如果 <code>targetStart &lt; 0</code> 、 <code>sourceStart &lt; 0</code> 、 <code>targetEnd &gt; target.byteLength</code> 或 <code>sourceEnd &gt; source.byteLength</code>，则抛出 <code>RangeError</code> 错误。</p>\n"
            },
            {
              "textRaw": "buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])",
              "type": "method",
              "name": "copy",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`target` {Buffer} 要拷贝进的 `Buffer` 。 ",
                      "name": "target",
                      "type": "Buffer",
                      "desc": "要拷贝进的 `Buffer` 。"
                    },
                    {
                      "textRaw": "`targetStart` {Integer} `target` 中开始拷贝进的偏移量。 **默认:** `0` ",
                      "name": "targetStart",
                      "type": "Integer",
                      "desc": "`target` 中开始拷贝进的偏移量。 **默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` {Integer} `buf` 中开始拷贝的偏移量。 当 `targetStart` 为 `undefined` 时忽略。 **默认:** `0` ",
                      "name": "sourceStart",
                      "type": "Integer",
                      "desc": "`buf` 中开始拷贝的偏移量。 当 `targetStart` 为 `undefined` 时忽略。 **默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` {Integer} `buf` 中结束拷贝的偏移量（不包含）。 当 `sourceStart` 为 `undefined` 时忽略。 **默认:** [`buf.length`] ",
                      "name": "sourceEnd",
                      "type": "Integer",
                      "desc": "`buf` 中结束拷贝的偏移量（不包含）。 当 `sourceStart` 为 `undefined` 时忽略。 **默认:** [`buf.length`]",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} 被拷贝的字节数。 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "被拷贝的字节数。"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "target"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>拷贝 <code>buf</code> 的一个区域的数据到 <code>target</code> 的一个区域，即便 <code>target</code> 的内存区域与 <code>buf</code> 的重叠。</p>\n<p>例子：创建两个 <code>Buffer</code> 实例 <code>buf1</code> 与 <code>buf2</code> ，并拷贝 <code>buf1</code> 中第 16 个至第 19 个字节到 <code>buf2</code> 第 8 个字节起。</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill(&#39;!&#39;);\n\nfor (let i = 0 ; i &lt; 26 ; i++) {\n  // 97 是 &#39;a&#39; 的十进制 ASCII 值\n  buf1[i] = i + 97;\n}\n\nbuf1.copy(buf2, 8, 16, 20);\n\n// 输出: !!!!!!!!qrst!!!!!!!!!!!!!\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, 25));\n</code></pre>\n<p>例子：创建一个 <code>Buffer</code> ，并拷贝同一 <code>Buffer</code> 中一个区域的数据到另一个重叠的区域。</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  // 97 是 &#39;a&#39; 的十进制 ASCII 值\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\n// 输出: efghijghijklmnopqrstuvwxyz\nconsole.log(buf.toString());\n</code></pre>\n"
            },
            {
              "textRaw": "buf.entries()",
              "type": "method",
              "name": "entries",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "返回: {Iterator} ",
                      "name": "返回",
                      "type": "Iterator"
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>从 <code>buf</code> 的内容中，创建并返回一个 <code>[index, byte]</code> 形式的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">迭代器</a>。</p>\n<p>例子：记录一个 <code>Buffer</code> 全部的内容。</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\n// 输出:\n//   [0, 98]\n//   [1, 117]\n//   [2, 102]\n//   [3, 102]\n//   [4, 101]\n//   [5, 114]\nfor (var pair of buf.entries()) {\n  console.log(pair);\n}\n</code></pre>\n"
            },
            {
              "textRaw": "buf.equals(otherBuffer)",
              "type": "method",
              "name": "equals",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.13"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`otherBuffer` {Buffer} 要比较的 `Buffer` ",
                      "name": "otherBuffer",
                      "type": "Buffer",
                      "desc": "要比较的 `Buffer`"
                    },
                    {
                      "textRaw": "返回: {Boolean} ",
                      "name": "返回",
                      "type": "Boolean"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "otherBuffer"
                    }
                  ]
                }
              ],
              "desc": "<p>如果 <code>buf</code> 与 <code>otherBuffer</code> 具有完全相同的字节，则返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;ABC&#39;);\nconst buf2 = Buffer.from(&#39;414243&#39;, &#39;hex&#39;);\nconst buf3 = Buffer.from(&#39;ABCD&#39;);\n\n// 输出: true\nconsole.log(buf1.equals(buf2));\n\n// 输出: false\nconsole.log(buf1.equals(buf3));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.fill(value[, offset[, end]][, encoding])",
              "type": "method",
              "name": "fill",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {String | Buffer | Integer} 用来填充 `buf` 的值 ",
                      "name": "value",
                      "type": "String | Buffer | Integer",
                      "desc": "用来填充 `buf` 的值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始填充 `buf` 的位置。**默认:** `0` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始填充 `buf` 的位置。**默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {Integer} 结束填充 `buf` 的位置（不包含）。**默认:** [`buf.length`] ",
                      "name": "end",
                      "type": "Integer",
                      "desc": "结束填充 `buf` 的位置（不包含）。**默认:** [`buf.length`]",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} 如果 `value` 是一个字符串，则这是它的字符编码。 **默认:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "如果 `value` 是一个字符串，则这是它的字符编码。 **默认:** `'utf8'`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Buffer} `buf` 的引用 ",
                      "name": "返回",
                      "type": "Buffer",
                      "desc": "`buf` 的引用"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>如果未指定 <code>offset</code> 和 <code>end</code>，则填充整个 <code>buf</code>。\n这个简化使得一个 <code>Buffer</code> 的创建与填充可以在一行内完成。</p>\n<p>例子：用 ASCII 字符 <code>&#39;h&#39;</code> 填充 <code>Buffer</code>。</p>\n<pre><code class=\"lang-js\">const b = Buffer.allocUnsafe(50).fill(&#39;h&#39;);\n\n// 输出: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\nconsole.log(b.toString());\n</code></pre>\n<p><code>value</code> 如果不是一个字符串或整数，则会被强行转换为 <code>uint32</code> 值。</p>\n<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,\nthen only the first bytes of that character that fit into <code>buf</code> are written.\n如果 <code>fill()</code> 操作的最后一次写入的是一个多字节字符，则只有字符中适合 <code>buf</code> 的第一个字节会被写入。</p>\n<p>例子：用一个两个字节的字符填充 <code>Buffer</code>。</p>\n<pre><code class=\"lang-js\">// 输出: &lt;Buffer c8 a2 c8&gt;\nconsole.log(Buffer.allocUnsafe(3).fill(&#39;\\u0222&#39;));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.indexOf(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "indexOf",
              "meta": {
                "added": [
                  "v1.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {String | Buffer | Integer} 要搜索的值 ",
                      "name": "value",
                      "type": "String | Buffer | Integer",
                      "desc": "要搜索的值"
                    },
                    {
                      "textRaw": "`byteOffset` {Integer} `buf` 中开始搜索的位置。**默认:** `0` ",
                      "name": "byteOffset",
                      "type": "Integer",
                      "desc": "`buf` 中开始搜索的位置。**默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} 如果 `value` 是一个字符串，则这是它的字符编码。 **默认:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "如果 `value` 是一个字符串，则这是它的字符编码。 **默认:** `'utf8'`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `buf` 中 `value` 首次出现的索引，如果 `buf` 没包含 `value` 则返回 `-1` ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`buf` 中 `value` 首次出现的索引，如果 `buf` 没包含 `value` 则返回 `-1`"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>如果 <code>value</code> 是：</p>\n<ul>\n<li>字符串，则 <code>value</code> 根据 <code>encoding</code> 的字符编码进行解析。</li>\n<li><code>Buffer</code>，则 <code>value</code> 会被作为一个整体使用。如果要比较部分 <code>Buffer</code> 可使用 <a href=\"#buffer_buf_slice_start_end\"><code>buf.slice()</code></a>。</li>\n<li>数值, 则 <code>value</code> 会解析为一个 <code>0</code> 至 <code>255</code> 之间的无符号八位整数值。</li>\n</ul>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;this is a buffer&#39;);\n\n// 输出: 0\nconsole.log(buf.indexOf(&#39;this&#39;)));\n\n// 输出: 2\nconsole.log(buf.indexOf(&#39;is&#39;));\n\n// 输出: 8\nconsole.log(buf.indexOf(Buffer.from(&#39;a buffer&#39;)));\n\n// 输出: 8\n// (97 是 &#39;a&#39; 的十进制 ASCII 值)\nconsole.log(buf.indexOf(97));\n\n// 输出: -1\nconsole.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;)));\n\n// 输出: 8\nconsole.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));\n\n\nconst utf16Buffer = Buffer.from(&#39;\\u039a\\u0391\\u03a3\\u03a3\\u0395&#39;, &#39;ucs2&#39;);\n\n// 输出: 4\nconsole.log(utf16Buffer.indexOf(&#39;\\u03a3&#39;, 0, &#39;ucs2&#39;));\n\n// 输出: 6\nconsole.log(utf16Buffer.indexOf(&#39;\\u03a3&#39;, -4, &#39;ucs2&#39;));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.includes(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "includes",
              "meta": {
                "added": [
                  "v5.3.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {String | Buffer | Integer} 要搜索的值 ",
                      "name": "value",
                      "type": "String | Buffer | Integer",
                      "desc": "要搜索的值"
                    },
                    {
                      "textRaw": "`byteOffset` {Integer} `buf` 中开始搜索的位置。**默认:** `0` ",
                      "name": "byteOffset",
                      "type": "Integer",
                      "desc": "`buf` 中开始搜索的位置。**默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} 如果 `value` 是一个字符串，则这是它的字符编码。 **默认:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "如果 `value` 是一个字符串，则这是它的字符编码。 **默认:** `'utf8'`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Boolean} 如果 `buf` 找到 `value`，则返回 `true`，否则返回 `false` ",
                      "name": "返回",
                      "type": "Boolean",
                      "desc": "如果 `buf` 找到 `value`，则返回 `true`，否则返回 `false`"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>相当于 <a href=\"#buffer_buf_indexof_value_byteoffset_encoding\"><code>buf.indexOf() !== -1</code></a>。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;this is a buffer&#39;);\n\n// 输出: true\nconsole.log(buf.includes(&#39;this&#39;));\n\n// 输出: true\nconsole.log(buf.includes(&#39;is&#39;));\n\n// 输出: true\nconsole.log(buf.includes(Buffer.from(&#39;a buffer&#39;)));\n\n// 输出: true\n// (97 是 &#39;a&#39; 的十进制 ASCII 值)\nconsole.log(buf.includes(97));\n\n// 输出: false\nconsole.log(buf.includes(Buffer.from(&#39;a buffer example&#39;)));\n\n// 输出: true\nconsole.log(buf.includes(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));\n\n// 输出: false\nconsole.log(buf.includes(&#39;this&#39;, 4));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.keys()",
              "type": "method",
              "name": "keys",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "返回: {Iterator} ",
                      "name": "返回",
                      "type": "Iterator"
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>创建并返回一个包含 <code>buf</code> 键名（索引）的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">迭代器</a>。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\n// 输出:\n//   0\n//   1\n//   2\n//   3\n//   4\n//   5\nfor (var key of buf.keys()) {\n  console.log(key);\n}\n</code></pre>\n"
            },
            {
              "textRaw": "buf.lastIndexOf(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "lastIndexOf",
              "meta": {
                "added": [
                  "v6.0.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {String | Buffer | Integer} 要搜索的值 ",
                      "name": "value",
                      "type": "String | Buffer | Integer",
                      "desc": "要搜索的值"
                    },
                    {
                      "textRaw": "`byteOffset` {Integer} `buf` 中开始搜索的位置（不包含）。 **默认:** [`buf.length`] ",
                      "name": "byteOffset",
                      "type": "Integer",
                      "desc": "`buf` 中开始搜索的位置（不包含）。 **默认:** [`buf.length`]",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} 如果 `value` 是一个字符串，则这是它的字符编码。 **默认:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "如果 `value` 是一个字符串，则这是它的字符编码。 **默认:** `'utf8'`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `buf` 中 `value` 最后一次出现的索引，如果 `buf` 没包含 `value` 则返回 `-1` ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`buf` 中 `value` 最后一次出现的索引，如果 `buf` 没包含 `value` 则返回 `-1`"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>与 <a href=\"#buffer_buf_indexof_value_byteoffset_encoding\"><code>buf.indexOf()</code></a> 类似，除了 <code>buf</code> 是从后往前搜索而不是从前往后。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;this buffer is a buffer&#39;);\n\n// 输出: 0\nconsole.log(buf.lastIndexOf(&#39;this&#39;));\n\n// 输出: 17\nconsole.log(buf.lastIndexOf(&#39;buffer&#39;));\n\n// 输出: 17\nconsole.log(buf.lastIndexOf(Buffer.from(&#39;buffer&#39;)));\n\n// 输出: 15\n// (97 是 &#39;a&#39; 的十进制 ASCII 值)\nconsole.log(buf.lastIndexOf(97));\n\n// 输出: -1\nconsole.log(buf.lastIndexOf(Buffer.from(&#39;yolo&#39;)));\n\n// 输出: 5\nconsole.log(buf.lastIndexOf(&#39;buffer&#39;, 5));\n\n// 输出: -1\nconsole.log(buf.lastIndexOf(&#39;buffer&#39;, 4));\n\n\nconst utf16Buffer = Buffer.from(&#39;\\u039a\\u0391\\u03a3\\u03a3\\u0395&#39;, &#39;ucs2&#39;);\n\n// 输出: 6\nconsole.log(utf16Buffer.lastIndexOf(&#39;\\u03a3&#39;, null, &#39;ucs2&#39;));\n\n// 输出: 4\nconsole.log(utf16Buffer.lastIndexOf(&#39;\\u03a3&#39;, -5, &#39;ucs2&#39;));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleBE(offset[, noAssert])",
              "type": "method",
              "name": "readDoubleBE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Number} ",
                      "name": "返回",
                      "type": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readDoubleBE()</code> 返回大尾数，<code>readDoubleLE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个64位双精度值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\n// 输出: 8.20788039913184e-304\nconsole.log(buf.readDoubleBE());\n\n// 输出: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE());\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readDoubleLE(1));\n\n// 警告: 读取超出 buffer 的末尾！\n// 这会导致内存区段错误！不要这么做！\nconsole.log(buf.readDoubleLE(1, true));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleLE(offset[, noAssert])",
              "type": "method",
              "name": "readDoubleLE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Number} ",
                      "name": "返回",
                      "type": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readDoubleBE()</code> 返回大尾数，<code>readDoubleLE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个64位双精度值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\n// 输出: 8.20788039913184e-304\nconsole.log(buf.readDoubleBE());\n\n// 输出: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE());\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readDoubleLE(1));\n\n// 警告: 读取超出 buffer 的末尾！\n// 这会导致内存区段错误！不要这么做！\nconsole.log(buf.readDoubleLE(1, true));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatBE(offset[, noAssert])",
              "type": "method",
              "name": "readFloatBE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Number} ",
                      "name": "返回",
                      "type": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readFloatBE()</code> 返回大尾数，<code>readFloatLE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个32位浮点值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4]);\n\n// 输出: 2.387939260590663e-38\nconsole.log(buf.readFloatBE());\n\n// 输出: 1.539989614439558e-36\nconsole.log(buf.readFloatLE());\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readFloatLE(1));\n\n// 警告: 读取超出 buffer 的末尾！\n// 这会导致内存区段错误！不要这么做！\nconsole.log(buf.readFloatLE(1, true));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatLE(offset[, noAssert])",
              "type": "method",
              "name": "readFloatLE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Number} ",
                      "name": "返回",
                      "type": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readFloatBE()</code> 返回大尾数，<code>readFloatLE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个32位浮点值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4]);\n\n// 输出: 2.387939260590663e-38\nconsole.log(buf.readFloatBE());\n\n// 输出: 1.539989614439558e-36\nconsole.log(buf.readFloatLE());\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readFloatLE(1));\n\n// 警告: 读取超出 buffer 的末尾！\n// 这会导致内存区段错误！不要这么做！\nconsole.log(buf.readFloatLE(1, true));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt8(offset[, noAssert])",
              "type": "method",
              "name": "readInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取一个有符号的8位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>从 <code>Buffer</code> 中读取的整数值会被解析为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([-1, 5]);\n\n// 输出: -1\nconsole.log(buf.readInt8(0));\n\n// 输出: 5\nconsole.log(buf.readInt8(1));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readInt8(2));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt16BE(offset[, noAssert])",
              "type": "method",
              "name": "readInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readInt16BE()</code> 返回大尾数，<code>readInt16LE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个有符号的16位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>从 <code>Buffer</code> 中读取的整数值会被解析为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 5]);\n\n// 输出: 5\nconsole.log(buf.readInt16BE());\n\n// 输出: 1280\nconsole.log(buf.readInt16LE(1));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readInt16LE(1));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt16LE(offset[, noAssert])",
              "type": "method",
              "name": "readInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readInt16BE()</code> 返回大尾数，<code>readInt16LE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个有符号的16位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>从 <code>Buffer</code> 中读取的整数值会被解析为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 5]);\n\n// 输出: 5\nconsole.log(buf.readInt16BE());\n\n// 输出: 1280\nconsole.log(buf.readInt16LE(1));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readInt16LE(1));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt32BE(offset[, noAssert])",
              "type": "method",
              "name": "readInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readInt32BE()</code> 返回大尾数，<code>readInt32LE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个有符号的32位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>从 <code>Buffer</code> 中读取的整数值会被解析为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 0, 0, 5]);\n\n// 输出: 5\nconsole.log(buf.readInt32BE());\n\n// 输出: 83886080\nconsole.log(buf.readInt32LE());\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readInt32LE(1));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt32LE(offset[, noAssert])",
              "type": "method",
              "name": "readInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readInt32BE()</code> 返回大尾数，<code>readInt32LE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个有符号的32位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>从 <code>Buffer</code> 中读取的整数值会被解析为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 0, 0, 5]);\n\n// 输出: 5\nconsole.log(buf.readInt32BE());\n\n// 输出: 83886080\nconsole.log(buf.readInt32LE());\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readInt32LE(1));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readIntBE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readIntBE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} 要读取的字节数。必须满足：`0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "要读取的字节数。必须满足：`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 和 `byteLength` 校验？ **默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 和 `byteLength` 校验？ **默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取 <code>byteLength</code> 个字节，且读取的值会被解析为二进制补码值。\n最高支持48位精度。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\n// 输出: 1234567890ab\nconsole.log(buf.readIntLE(0, 6).toString(16));\n\n// 输出: -546f87a9cbee\nconsole.log(buf.readIntBE(0, 6).toString(16));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readIntBE(1, 6).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readIntLE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readIntLE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} 要读取的字节数。必须满足：`0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "要读取的字节数。必须满足：`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 和 `byteLength` 校验？ **默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 和 `byteLength` 校验？ **默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取 <code>byteLength</code> 个字节，且读取的值会被解析为二进制补码值。\n最高支持48位精度。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\n// 输出: 1234567890ab\nconsole.log(buf.readIntLE(0, 6).toString(16));\n\n// 输出: -546f87a9cbee\nconsole.log(buf.readIntBE(0, 6).toString(16));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readIntBE(1, 6).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt8(offset[, noAssert])",
              "type": "method",
              "name": "readUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取一个无符号的8位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, -2]);\n\n// 输出: 1\nconsole.log(buf.readUInt8(0));\n\n// 输出: 254\nconsole.log(buf.readUInt8(1));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readUInt8(2));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16BE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readUInt16BE()</code> 返回大尾数，<code>readUInt16LE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个无符号的16位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56]);\n\n// 输出: 1234\nconsole.log(buf.readUInt16BE(0).toString(16));\n\n// 输出: 3412\nconsole.log(buf.readUInt16LE(0).toString(16));\n\n// 输出: 3456\nconsole.log(buf.readUInt16BE(1).toString(16));\n\n// 输出: 5634\nconsole.log(buf.readUInt16LE(1).toString(16));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readUInt16LE(2).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16LE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readUInt16BE()</code> 返回大尾数，<code>readUInt16LE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个无符号的16位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56]);\n\n// 输出: 1234\nconsole.log(buf.readUInt16BE(0).toString(16));\n\n// 输出: 3412\nconsole.log(buf.readUInt16LE(0).toString(16));\n\n// 输出: 3456\nconsole.log(buf.readUInt16BE(1).toString(16));\n\n// 输出: 5634\nconsole.log(buf.readUInt16LE(1).toString(16));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readUInt16LE(2).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32BE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readUInt32BE()</code> 返回大尾数，<code>readUInt32LE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个无符号的32位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\n// 输出: 12345678\nconsole.log(buf.readUInt32BE(0).toString(16));\n\n// 输出: 78563412\nconsole.log(buf.readUInt32LE(0).toString(16));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readUInt32LE(1).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32LE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>readUInt32BE()</code> 返回大尾数，<code>readUInt32LE()</code> 返回小尾数）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个无符号的32位整数值。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\n// 输出: 12345678\nconsole.log(buf.readUInt32BE(0).toString(16));\n\n// 输出: 78563412\nconsole.log(buf.readUInt32LE(0).toString(16));\n\n// 抛出异常: RangeError: Index out of range\nconsole.log(buf.readUInt32LE(1).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUIntBE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readUIntBE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} 要读取的字节数。必须满足：`0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "要读取的字节数。必须满足：`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 和 `byteLength` 校验？ **默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 和 `byteLength` 校验？ **默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取 <code>byteLength</code> 个字节，且读取的值会被解析为无符号的整数。\n最高支持48位精度。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\n// 输出: 1234567890ab\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n\n// 输出: ab9078563412\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n\n//抛出异常: RangeError: Index out of range\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUIntLE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readUIntLE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} 开始读取的位置，必须满足：`0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始读取的位置，必须满足：`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} 要读取的字节数。必须满足：`0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "要读取的字节数。必须满足：`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `offset` 和 `byteLength` 校验？ **默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `offset` 和 `byteLength` 校验？ **默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} ",
                      "name": "返回",
                      "type": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取 <code>byteLength</code> 个字节，且读取的值会被解析为无符号的整数。\n最高支持48位精度。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\n// 输出: 1234567890ab\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n\n// 输出: ab9078563412\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n\n//抛出异常: RangeError: Index out of range\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.slice([start[, end]])",
              "type": "method",
              "name": "slice",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`start` {Integer} 新建的 `Buffer` 开始的位置。 **默认:** `0` ",
                      "name": "start",
                      "type": "Integer",
                      "desc": "新建的 `Buffer` 开始的位置。 **默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {Integer} 新建的 `Buffer` 结束的位置（不包含）。 **默认:** [`buf.length`] ",
                      "name": "end",
                      "type": "Integer",
                      "desc": "新建的 `Buffer` 结束的位置（不包含）。 **默认:** [`buf.length`]",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Buffer} ",
                      "name": "返回",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>返回一个指向相同原始内存的新建的 <code>Buffer</code>，但做了偏移且通过 <code>start</code> 和 <code>end</code> 索引进行裁剪。</p>\n<p><strong>注意，修改这个新建的 <code>Buffer</code> 切片，也会同时修改原始的 <code>Buffer</code> 的内存，因为这两个对象所分配的内存是重叠的。</strong></p>\n<p>例子：创建一个包含 ASCII 字母表的 <code>Buffer</code>，并进行切片，然后修改原始 <code>Buffer</code> 上的一个字节。</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.allocUnsafe(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  // 97 是 &#39;a&#39; 的十进制 ASCII 值 \n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.slice(0, 3);\n\n// 输出: abc\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\n\nbuf1[0] = 33;\n\n// 输出: !bc\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\n</code></pre>\n<p>指定负的索引会导致切片的生成是相对于 <code>buf</code> 的末尾而不是开头。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\n// 输出: buffe\n// (相当于 buf.slice(0, 5))\nconsole.log(buf.slice(-6, -1).toString());\n\n// 输出: buff\n// (相当于 buf.slice(0, 4))\nconsole.log(buf.slice(-6, -2).toString());\n\n// 输出: uff\n// (相当于 buf.slice(1, 4))\nconsole.log(buf.slice(-5, -2).toString());\n</code></pre>\n"
            },
            {
              "textRaw": "buf.swap16()",
              "type": "method",
              "name": "swap16",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "返回: {Buffer} `buf` 的引用 ",
                      "name": "返回",
                      "type": "Buffer",
                      "desc": "`buf` 的引用"
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>将 <code>buf</code> 解析为一个无符号16位的整数数组，并且以字节顺序原地进行交换。\n如果 <a href=\"#buffer_buf_length\"><code>buf.length</code></a> 不是2的倍数，则抛出 <code>RangeError</code> 错误。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;\nconsole.log(buf1);\n\nbuf1.swap16();\n\n// 输出: &lt;Buffer 02 01 04 03 06 05 08 07&gt;\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// 抛出异常: RangeError: Buffer size must be a multiple of 16-bits\nbuf2.swap16();\n</code></pre>\n"
            },
            {
              "textRaw": "buf.swap32()",
              "type": "method",
              "name": "swap32",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "返回: {Buffer} `buf` 的引用 ",
                      "name": "返回",
                      "type": "Buffer",
                      "desc": "`buf` 的引用"
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>将 <code>buf</code> 解析为一个无符号32位的整数数组，并且以字节顺序原地进行交换。\n如果 <a href=\"#buffer_buf_length\"><code>buf.length</code></a> 不是4的倍数，则抛出 <code>RangeError</code> 错误。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;\nconsole.log(buf1);\n\nbuf1.swap32();\n\n// 输出: &lt;Buffer 04 03 02 01 08 07 06 05&gt;\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// 抛出异常: RangeError: Buffer size must be a multiple of 32-bits\nbuf2.swap32();\n</code></pre>\n"
            },
            {
              "textRaw": "buf.swap64()",
              "type": "method",
              "name": "swap64",
              "meta": {
                "added": [
                  "v6.3.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "返回: {Buffer} `buf` 的引用 ",
                      "name": "返回",
                      "type": "Buffer",
                      "desc": "`buf` 的引用"
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>将 <code>buf</code> 解析为一个64位的数值数组，并且以字节顺序原地进行交换。\n如果 <a href=\"#buffer_buf_length\"><code>buf.length</code></a> 不是8的倍数，则抛出 <code>RangeError</code> 错误。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;\nconsole.log(buf1);\n\nbuf1.swap64();\n\n// 输出: &lt;Buffer 08 07 06 05 04 03 02 01&gt;\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// 抛出异常: RangeError: Buffer size must be a multiple of 64-bits\nbuf2.swap64();\n</code></pre>\n<p>注意，JavaScript 不能编码64位整数。\n该方法是用来处理64位浮点数的。</p>\n"
            },
            {
              "textRaw": "buf.toString([encoding[, start[, end]]])",
              "type": "method",
              "name": "toString",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`encoding` {String} 解码使用的字符编码。**默认:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "解码使用的字符编码。**默认:** `'utf8'`",
                      "optional": true
                    },
                    {
                      "textRaw": "`start` {Integer} 开始解码的字节偏移量。**默认:** `0` ",
                      "name": "start",
                      "type": "Integer",
                      "desc": "开始解码的字节偏移量。**默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {Integer} 结束解码的字节偏移量（不包含）。 **默认:** [`buf.length`] ",
                      "name": "end",
                      "type": "Integer",
                      "desc": "结束解码的字节偏移量（不包含）。 **默认:** [`buf.length`]",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {String} ",
                      "name": "返回",
                      "type": "String"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>根据 <code>encoding</code> 指定的字符编码解码 <code>buf</code> 成一个字符串。\n<code>start</code> 和 <code>end</code> 可传入用于只解码 <code>buf</code> 的一部分。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.allocUnsafe(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  // 97 是 &#39;a&#39; 的十进制 ASCII 值\n  buf1[i] = i + 97;\n}\n\n// 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf1.toString(&#39;ascii&#39;));\n\n// 输出: abcde\nconsole.log(buf1.toString(&#39;ascii&#39;, 0, 5));\n\n\nconst buf2 = Buffer.from(&#39;tést&#39;);\n\n// 输出: 74c3a97374\nconsole.log(buf2.toString(&#39;hex&#39;));\n\n// 输出: té\nconsole.log(buf2.toString(&#39;utf8&#39;, 0, 3));\n\n// 输出: té\nconsole.log(buf2.toString(undefined, 0, 3));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.toJSON()",
              "type": "method",
              "name": "toJSON",
              "meta": {
                "added": [
                  "v0.9.2"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "返回: {Object} ",
                      "name": "返回",
                      "type": "Object"
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>返回 <code>buf</code> 的 JSON 格式。\n当字符串化一个 <code>Buffer</code> 实例时，<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"><code>JSON.stringify()</code></a> 会隐式地调用该函数。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\n// 输出: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}\nconsole.log(json);\n\nconst copy = JSON.parse(json, (key, value) =&gt; {\n  return value &amp;&amp; value.type === &#39;Buffer&#39;\n    ? Buffer.from(value.data)\n    : value;\n});\n\n// 输出: &lt;Buffer 01 02 03 04 05&gt;\nconsole.log(copy);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.values()",
              "type": "method",
              "name": "values",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "返回: {Iterator} ",
                      "name": "返回",
                      "type": "Iterator"
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>创建并返回一个包含 <code>buf</code> 的值（字节）的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">迭代器</a>。\n当 <code>Buffer</code> 使用 <code>for..of</code> 时会自动调用该函数。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\n// 输出:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\nfor (var value of buf.values()) {\n  console.log(value);\n}\n\n// 输出:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\nfor (var value of buf) {\n  console.log(value);\n}\n</code></pre>\n"
            },
            {
              "textRaw": "buf.write(string[, offset[, length]][, encoding])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`string` {String} 要写入 `buf` 的字符串 ",
                      "name": "string",
                      "type": "String",
                      "desc": "要写入 `buf` 的字符串"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入 `string` 的位置。**默认:** `0` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入 `string` 的位置。**默认:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {Integer} 要写入的字节数。**默认:** `buf.length - offset` ",
                      "name": "length",
                      "type": "Integer",
                      "desc": "要写入的字节数。**默认:** `buf.length - offset`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} `string` 的字符编码。**默认:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "`string` 的字符编码。**默认:** `'utf8'`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} 写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>根据 <code>encoding</code> 的字符编码写入 <code>string</code> 到 <code>buf</code> 中的 <code>offset</code> 位置。\n<code>length</code> 参数是写入的字节数。\n如果 <code>buf</code> 没有足够的空间保存整个字符串，则只会写入 <code>string</code> 的一部分。\n只部分解码的字符不会被写入。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(256);\n\nconst len = buf.write(&#39;\\u00bd + \\u00bc = \\u00be&#39;, 0);\n\n// 输出: 12 个字节: ½ + ¼ = ¾\nconsole.log(`${len} 个字节: ${buf.toString(&#39;utf8&#39;, 0, len)}`);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleBE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeDoubleBE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Number} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Number",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeDoubleBE()</code> 写入大尾数，<code>writeDoubleLE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的64位双精度值。\n当 <code>value</code> 不是一个64位双精度值时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\n// 输出: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\n// 输出: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleLE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeDoubleLE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Number} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Number",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeDoubleBE()</code> 写入大尾数，<code>writeDoubleLE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的64位双精度值。\n当 <code>value</code> 不是一个64位双精度值时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\n// 输出: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\n// 输出: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatBE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeFloatBE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Number} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Number",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeFloatBE()</code> 写入大尾数，<code>writeFloatLE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的32位浮点值。\n当 <code>value</code> 不是一个32位浮点值时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\n// 输出: &lt;Buffer 4f 4a fe bb&gt;\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\n// 输出: &lt;Buffer bb fe 4a 4f&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatLE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeFloatLE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Number} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Number",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeFloatBE()</code> 写入大尾数，<code>writeFloatLE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的32位浮点值。\n当 <code>value</code> 不是一个32位浮点值时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\n// 输出: &lt;Buffer 4f 4a fe bb&gt;\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\n// 输出: &lt;Buffer bb fe 4a 4f&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt8(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的有符号的8位整数。\n当 <code>value</code> 不是一个有符号的8位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p><code>value</code> 会被解析并写入为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\n// 输出: &lt;Buffer 02 fe&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt16BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeInt16BE()</code> 写入大尾数，<code>writeInt16LE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的有符号的16位整数。\n当 <code>value</code> 不是一个有符号的16位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p><code>value</code> 会被解析并写入为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt16BE(0x0102, 0);\nbuf.writeInt16LE(0x0304, 2);\n\n// 输出: &lt;Buffer 01 02 04 03&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt16LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeInt16BE()</code> 写入大尾数，<code>writeInt16LE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的有符号的16位整数。\n当 <code>value</code> 不是一个有符号的16位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p><code>value</code> 会被解析并写入为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt16BE(0x0102, 0);\nbuf.writeInt16LE(0x0304, 2);\n\n// 输出: &lt;Buffer 01 02 04 03&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt32BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeInt32BE()</code> 写入大尾数，<code>writeInt32LE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的有符号的32位整数。\n当 <code>value</code> 不是一个有符号的32位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p><code>value</code> 会被解析并写入为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeInt32BE(0x01020304, 0);\nbuf.writeInt32LE(0x05060708, 4);\n\n// 输出: &lt;Buffer 01 02 03 04 08 07 06 05&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt32LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeInt32BE()</code> 写入大尾数，<code>writeInt32LE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的有符号的32位整数。\n当 <code>value</code> 不是一个有符号的32位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p><code>value</code> 会被解析并写入为二进制补码值。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeInt32BE(0x01020304, 0);\nbuf.writeInt32LE(0x05060708, 4);\n\n// 输出: &lt;Buffer 01 02 03 04 08 07 06 05&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeIntBE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeIntBE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} 要写入的字节数，必须满足：`0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "要写入的字节数，必须满足：`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value`、`offset` 和 `byteLength` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value`、`offset` 和 `byteLength` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>写入 <code>value</code> 中的 <code>byteLength</code> 个字节到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n最高支持48位精度。\n当 <code>value</code> 不是一个有符号的整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\n// 输出: &lt;Buffer 12 34 56 78 90 ab&gt;\nconsole.log(buf);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\n// 输出: &lt;Buffer ab 90 78 56 34 12&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeIntLE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeIntLE",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.15"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} 要写入的字节数，必须满足：`0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "要写入的字节数，必须满足：`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value`、`offset` 和 `byteLength` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value`、`offset` 和 `byteLength` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>写入 <code>value</code> 中的 <code>byteLength</code> 个字节到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n最高支持48位精度。\n当 <code>value</code> 不是一个有符号的整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\n// 输出: &lt;Buffer 12 34 56 78 90 ab&gt;\nconsole.log(buf);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\n// 输出: &lt;Buffer ab 90 78 56 34 12&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt8(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的无符号的8位整数。\n当 <code>value</code> 不是一个无符号的8位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\n// 输出: &lt;Buffer 03 04 23 42&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeUInt16BE()</code> 写入大尾数，<code>writeUInt16LE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的无符号的16位整数。\n当 <code>value</code> 不是一个无符号的16位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\n// 输出: &lt;Buffer de ad be ef&gt;\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\n// 输出: &lt;Buffer ad de ef be&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeUInt16BE()</code> 写入大尾数，<code>writeUInt16LE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的无符号的16位整数。\n当 <code>value</code> 不是一个无符号的16位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\n// 输出: &lt;Buffer de ad be ef&gt;\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\n// 输出: &lt;Buffer ad de ef be&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeUInt32BE()</code> 写入大尾数，<code>writeUInt32LE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的无符号的32位整数。\n当 <code>value</code> 不是一个无符号的32位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\n// 输出: &lt;Buffer fe ed fa ce&gt;\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\n// 输出: &lt;Buffer ce fa ed fe&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value` 和 `offset` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value` 和 `offset` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>用指定的尾数格式（<code>writeUInt32BE()</code> 写入大尾数，<code>writeUInt32LE()</code> 写入小尾数）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n<code>value</code> 应当是一个有效的无符号的32位整数。\n当 <code>value</code> 不是一个无符号的32位整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\n// 输出: &lt;Buffer fe ed fa ce&gt;\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\n// 输出: &lt;Buffer ce fa ed fe&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUIntBE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeUIntBE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} 要写入的字节数，必须满足：`0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "要写入的字节数，必须满足：`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value`、`offset` 和 `byteLength` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value`、`offset` 和 `byteLength` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>写入 <code>value</code> 中的 <code>byteLength</code> 个字节到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n最高支持48位精度。\n当 <code>value</code> 不是一个无符号的整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\n// 输出: &lt;Buffer 12 34 56 78 90 ab&gt;\nconsole.log(buf);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\n// 输出: &lt;Buffer ab 90 78 56 34 12&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUIntLE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeUIntLE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` {Integer} 要写入 `buf` 的数值 ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "要写入 `buf` 的数值"
                    },
                    {
                      "textRaw": "`offset` {Integer} 开始写入的位置，必须满足：`0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "开始写入的位置，必须满足：`0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} 要写入的字节数，必须满足：`0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "要写入的字节数，必须满足：`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} 是否跳过 `value`、`offset` 和 `byteLength` 检验？**默认:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "是否跳过 `value`、`offset` 和 `byteLength` 检验？**默认:** `false`",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Integer} `offset` 加上写入的字节数 ",
                      "name": "返回",
                      "type": "Integer",
                      "desc": "`offset` 加上写入的字节数"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>写入 <code>value</code> 中的 <code>byteLength</code> 个字节到 <code>buf</code> 中指定的 <code>offset</code> 位置。\n最高支持48位精度。\n当 <code>value</code> 不是一个无符号的整数时，反应是不确定的。</p>\n<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\n// 输出: &lt;Buffer 12 34 56 78 90 ab&gt;\nconsole.log(buf);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\n// 输出: &lt;Buffer ab 90 78 56 34 12&gt;\nconsole.log(buf);\n</code></pre>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`array` {Array} An array of bytes to copy from ",
                  "name": "array",
                  "type": "Array",
                  "desc": "An array of bytes to copy from"
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a> 代替。</p>\n<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">// Creates a new Buffer containing the ASCII bytes of the string &#39;buffer&#39;\nconst buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "array"
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a> 代替。</p>\n<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">// Creates a new Buffer containing the ASCII bytes of the string &#39;buffer&#39;\nconst buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`buffer` {Buffer} An existing `Buffer` to copy data from ",
                  "name": "buffer",
                  "type": "Buffer",
                  "desc": "An existing `Buffer` to copy data from"
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a> 代替。</p>\n<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;buffer&#39;);\nconst buf2 = new Buffer(buf1);\n\nbuf1[0] = 0x61;\n\n// Prints: auffer\nconsole.log(buf1.toString());\n\n// Prints: buffer\nconsole.log(buf2.toString());\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "buffer"
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a> 代替。</p>\n<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;buffer&#39;);\nconst buf2 = new Buffer(buf1);\n\nbuf1[0] = 0x61;\n\n// Prints: auffer\nconsole.log(buf1.toString());\n\n// Prints: buffer\nconsole.log(buf2.toString());\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`arrayBuffer` {ArrayBuffer} The `.buffer` property of a [`TypedArray`] or [`ArrayBuffer`] ",
                  "name": "arrayBuffer",
                  "type": "ArrayBuffer",
                  "desc": "The `.buffer` property of a [`TypedArray`] or [`ArrayBuffer`]"
                },
                {
                  "textRaw": "`byteOffset` {Integer} Where to start copying from `arrayBuffer`. **Default:** `0` ",
                  "name": "byteOffset",
                  "type": "Integer",
                  "desc": "Where to start copying from `arrayBuffer`. **Default:** `0`",
                  "optional": true
                },
                {
                  "textRaw": "`length` {Integer} How many bytes to copy from `arrayBuffer`. **Default:** `arrayBuffer.length - byteOffset` ",
                  "name": "length",
                  "type": "Integer",
                  "desc": "How many bytes to copy from `arrayBuffer`. **Default:** `arrayBuffer.length - byteOffset`",
                  "optional": true
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a> 代替。</p>\n<p>When passed a reference to the <code>.buffer</code> property of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance,\nthe newly created <code>Buffer</code> will share the same allocated memory as the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = new Buffer(arr.buffer);\n\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\nconsole.log(buf);\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\n// Prints: &lt;Buffer 88 13 70 17&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "arrayBuffer"
                },
                {
                  "name": "byteOffset",
                  "optional": true
                },
                {
                  "name": "length",
                  "optional": true
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a> 代替。</p>\n<p>When passed a reference to the <code>.buffer</code> property of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance,\nthe newly created <code>Buffer</code> will share the same allocated memory as the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = new Buffer(arr.buffer);\n\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\nconsole.log(buf);\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\n// Prints: &lt;Buffer 88 13 70 17&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`size` {Integer} The desired length of the new `Buffer` ",
                  "name": "size",
                  "type": "Integer",
                  "desc": "The desired length of the new `Buffer`"
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> 代替（或 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>）。</p>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  The <code>size</code> must be less than or equal\nto the value of <a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a>. Otherwise, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> is thrown.\nA zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>\n<p>Unlike <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffers</code></a>, the underlying memory for <code>Buffer</code> instances\ncreated in this way is <em>not initialized</em>. The contents of a newly created <code>Buffer</code>\nare unknown and <em>could contain sensitive data</em>. Use\n<a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size)</code></a> instead to initialize a <code>Buffer</code> to zeroes.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(5);\n\n// Prints: (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> 代替（或 <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>）。</p>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  The <code>size</code> must be less than or equal\nto the value of <a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a>. Otherwise, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> is thrown.\nA zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>\n<p>Unlike <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffers</code></a>, the underlying memory for <code>Buffer</code> instances\ncreated in this way is <em>not initialized</em>. The contents of a newly created <code>Buffer</code>\nare unknown and <em>could contain sensitive data</em>. Use\n<a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size)</code></a> instead to initialize a <code>Buffer</code> to zeroes.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(5);\n\n// Prints: (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`string` {String} String to encode ",
                  "name": "string",
                  "type": "String",
                  "desc": "String to encode"
                },
                {
                  "textRaw": "`encoding` {String} The encoding of `string`. **Default:** `'utf8'` ",
                  "name": "encoding",
                  "type": "String",
                  "desc": "The encoding of `string`. **Default:** `'utf8'`",
                  "optional": true
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> 代替。</p>\n<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>string</code>. If\nprovided, the <code>encoding</code> parameter identifies the character encoding of <code>string</code>.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;this is a tést&#39;);\n\n// Prints: this is a tést\nconsole.log(buf1.toString());\n\n// Prints: this is a tC)st\nconsole.log(buf1.toString(&#39;ascii&#39;));\n\n\nconst buf2 = new Buffer(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\n\n// Prints: this is a tést\nconsole.log(buf2.toString());\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "string"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> 代替。</p>\n<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>string</code>. If\nprovided, the <code>encoding</code> parameter identifies the character encoding of <code>string</code>.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;this is a tést&#39;);\n\n// Prints: this is a tést\nconsole.log(buf1.toString());\n\n// Prints: this is a tC)st\nconsole.log(buf1.toString(&#39;ascii&#39;));\n\n\nconst buf2 = new Buffer(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\n\n// Prints: this is a tést\nconsole.log(buf2.toString());\n</code></pre>\n"
            }
          ]
        },
        {
          "textRaw": "Class: SlowBuffer",
          "type": "class",
          "name": "SlowBuffer",
          "meta": {
            "deprecated": [
              "v6.0.0"
            ]
          },
          "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a> 代替。</p>\n<p>Returns an un-pooled <code>Buffer</code>.</p>\n<p>In order to avoid the garbage collection overhead of creating many individually\nallocated <code>Buffer</code> instances, by default allocations under 4KB are sliced from a\nsingle larger allocated object. This approach improves both performance and memory\nusage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.</p>\n<p>In the case where a developer may need to retain a small chunk of memory from a\npool for an indeterminate amount of time, it may be appropriate to create an\nun-pooled <code>Buffer</code> instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">// Need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on(&#39;readable&#39;, () =&gt; {\n  const data = socket.read();\n\n  // Allocate for retained data\n  const sb = SlowBuffer(10);\n\n  // Copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n</code></pre>\n<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer\nhas observed undue memory retention in their applications.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`size` {Integer} The desired length of the new `SlowBuffer` ",
                  "name": "size",
                  "type": "Integer",
                  "desc": "The desired length of the new `SlowBuffer`"
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a> 代替。</p>\n<p>Allocates a new <code>SlowBuffer</code> of <code>size</code> bytes. The <code>size</code> must be less than\nor equal to the value of <a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a>. Otherwise, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> is\nthrown. A zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>\n<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The\ncontents of a newly created <code>SlowBuffer</code> are unknown and could contain\nsensitive data. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> to zeroes.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const SlowBuffer = require(&#39;buffer&#39;).SlowBuffer;\n\nconst buf = new SlowBuffer(5);\n\n// Prints: (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>稳定性: 0 - 废弃的: 使用 <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a> 代替。</p>\n<p>Allocates a new <code>SlowBuffer</code> of <code>size</code> bytes. The <code>size</code> must be less than\nor equal to the value of <a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a>. Otherwise, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> is\nthrown. A zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>\n<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The\ncontents of a newly created <code>SlowBuffer</code> are unknown and could contain\nsensitive data. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> to zeroes.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const SlowBuffer = require(&#39;buffer&#39;).SlowBuffer;\n\nconst buf = new SlowBuffer(5);\n\n// Prints: (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n"
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`INSPECT_MAX_BYTES` {Integer} **默认:** `50` ",
          "type": "Integer",
          "name": "INSPECT_MAX_BYTES",
          "meta": {
            "added": [
              "v0.5.4"
            ]
          },
          "desc": "<p>当调用 <code>buf.inspect()</code> 时返回的最大字节数。\n可以被用户模块重写。\n详见 <a href=\"util.html#util_util_inspect_object_options\"><code>util.inspect()</code></a> 了解更多 <code>buf.inspect()</code> 的行为。</p>\n<p>注意，这个属性是在通过 <code>require(&#39;buffer&#39;)</code> 返回的 <code>buffer</code> 模块上，而不是在 <code>Buffer</code> 的全局变量或 <code>Buffer</code> 实例上。</p>\n",
          "shortDesc": "**默认:** `50`"
        },
        {
          "textRaw": "`kMaxLength` {Integer} 分配给单个 `Buffer` 实例的最大内存 ",
          "type": "Integer",
          "name": "kMaxLength",
          "meta": {
            "added": [
              "v3.0.0"
            ]
          },
          "desc": "<p>在32位架构上，该值为 <code>(2^30)-1</code> (~1GB)。\n在64位架构上，该值为 <code>(2^31)-1</code> (~2GB)。</p>\n",
          "shortDesc": "分配给单个 `Buffer` 实例的最大内存"
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    }
  ]
}