{
  "source": "http://nodejs.cn/api/cn/api/child_process.md",
  "modules": [
    {
      "textRaw": "Child Process",
      "name": "child_process",
      "desc": "<p>稳定性: 2 - 稳定的</p>\n<p><code>child_process</code> 模块提供了衍生子进程的能力，它与 popen(3) 类似，但不完全相同。\n这个能力主要由 <a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a> 函数提供：</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst ls = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]);\n\nls.stdout.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`stdout: ${data}`);\n});\n\nls.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`stderr: ${data}`);\n});\n\nls.on(&#39;close&#39;, (code) =&gt; {\n  console.log(`子进程退出码：${code}`);\n});\n</code></pre>\n<p>默认情况下，在 Node.js 的父进程和衍生的子进程之间会建立 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 的管道。\n这使得数据可以以非阻塞的方式在这些管道流通。\n注意，有些程序会在内部使用行缓冲 I/O。\n虽然这并不影响 Node.js，但这意味着发送到子过程的数据可能无法被立即消费。</p>\n<p><a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a> 方法会异步地衍生子进程，且不会阻塞 Node.js 的事件循环。\n<a href=\"#child_process_child_process_spawnsync_command_args_options\"><code>child_process.spawnSync()</code></a> 函数则以同步的方式提供了同样的功能，但会阻塞事件循环，直到衍生的子进程退出或终止。</p>\n<p>为了方便起见，<code>child_process</code> 模块提供了一些同步和异步的替代方法用于  <a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a> 和 <a href=\"#child_process_child_process_spawnsync_command_args_options\"><code>child_process.spawnSync()</code></a>。\n注意，每个替代方法都是在 <a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a> 或 <a href=\"#child_process_child_process_spawnsync_command_args_options\"><code>child_process.spawnSync()</code></a> 的基础上实现的。</p>\n<ul>\n<li><a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a>: 衍生一个 shell 并在 shell 上运行一个命令，当完成时会传入 <code>stdout</code> 和 <code>stderr</code> 到一个回调。</li>\n<li><a href=\"#child_process_child_process_execfile_file_args_options_callback\"><code>child_process.execFile()</code></a>: 和  <a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 类似，除了它直接衍生命令，且不用先衍生一个 shell。</li>\n<li><a href=\"#child_process_child_process_fork_modulepath_args_options\"><code>child_process.fork()</code></a>: 衍生一个新的 Node.js 进程，并通过建立一个允许父进程和子进程之间相互发送信息的 IPC 通讯通道来调用一个指定的模块。</li>\n<li><a href=\"#child_process_child_process_execsync_command_options\"><code>child_process.execSync()</code></a>: <a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 的一个同步版本，它会阻塞 Node.js 的事件循环。</li>\n<li><a href=\"#child_process_child_process_execfilesync_file_args_options\"><code>child_process.execFileSync()</code></a>: <a href=\"#child_process_child_process_execfile_file_args_options_callback\"><code>child_process.execFile()</code></a> 的一个同步版本，它会阻塞 Node.js 的事件循环。</li>\n</ul>\n<p>对于某些用例，如自动化的 shell 脚本，<a href=\"#child_process_synchronous_process_creation\">同步的版本</a>可能更方便。\n大多数情况下，同步的方法会显著地影响性能，因为它拖延了事件循环直到衍生进程完成。</p>\n",
      "modules": [
        {
          "textRaw": "Asynchronous Process Creation",
          "name": "asynchronous_process_creation",
          "desc": "<p><a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a>、<a href=\"#child_process_child_process_fork_modulepath_args_options\"><code>child_process.fork()</code></a>、<a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 和 <a href=\"#child_process_child_process_execfile_file_args_options_callback\"><code>child_process.execFile()</code></a> 方法都遵循与其他 Node.js API 一样的惯用的异步编程模式。</p>\n<p>每个方法都返回一个 <a href=\"#child_process_child_process\"><code>ChildProcess</code></a> 实例。\n这些对象实现了 Node.js <a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a> 的 API，允许父进程注册监听器函数，在子进程生命周期期间，当特定的事件发生时会调用这些函数。</p>\n<p><a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 和 <a href=\"#child_process_child_process_execfile_file_args_options_callback\"><code>child_process.execFile()</code></a> 返回可以额外指定一个可选的 <code>callback</code> 函数，当子进程结束时会被调用。</p>\n",
          "modules": [
            {
              "textRaw": "Spawning `.bat` and `.cmd` files on Windows",
              "name": "spawning_`.bat`_and_`.cmd`_files_on_windows",
              "desc": "<p><a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 和 <a href=\"#child_process_child_process_execfile_file_args_options_callback\"><code>child_process.execFile()</code></a> 之间的重大区别会根据平台的不同而不同。\n在类 Unix 操作系统上（Unix、 Linux、 OSX），<a href=\"#child_process_child_process_execfile_file_args_options_callback\"><code>child_process.execFile()</code></a> 效率更高，因为它不需要衍生一个 shell。\n但是在 Windows 上，<code>.bat</code> 和 <code>.cmd</code> 文件在没有终端的情况下是不可执行的，因此不能使用 <a href=\"#child_process_child_process_execfile_file_args_options_callback\"><code>child_process.execFile()</code></a> 启动。\n当在 Windows 下运行时，要调用 <code>.bat</code> 和 <code>.cmd</code> 文件，可以通过使用设置了 <code>shell</code> 选项的 <a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a>、或使用 <a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a>、或衍生 <code>cmd.exe</code> 并将 <code>.bat</code> 或 <code>.cmd</code> 文件作为一个参数传入（也就是 <code>shell</code> 选项和 <a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 所做的工作）。\n在任何情况下，如果脚本文件名包含了空格，则需要用加上引号。</p>\n<pre><code class=\"lang-js\">// 仅限 Windows 系统\nconst spawn = require(&#39;child_process&#39;).spawn;\nconst bat = spawn(&#39;cmd.exe&#39;, [&#39;/c&#39;, &#39;my.bat&#39;]);\n\nbat.stdout.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data);\n});\n\nbat.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data);\n});\n\nbat.on(&#39;exit&#39;, (code) =&gt; {\n  console.log(`子进程退出码：${code}`);\n});\n\n// 或\nconst exec = require(&#39;child_process&#39;).exec;\nexec(&#39;my.bat&#39;, (err, stdout, stderr) =&gt; {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log(stdout);\n});\n\n// 文件名带有空格的脚本：\nconst bat = spawn(&#39;&quot;my script.cmd&quot;&#39;, [&#39;a&#39;, &#39;b&#39;], { shell:true });\n// 或：\nexec(&#39;&quot;my script.cmd&quot; a b&#39;, (err, stdout, stderr) =&gt; {\n  // ...\n});\n</code></pre>\n",
              "type": "module",
              "displayName": "Spawning `.bat` and `.cmd` files on Windows"
            }
          ],
          "methods": [
            {
              "textRaw": "child_process.exec(command[, options][, callback])",
              "type": "method",
              "name": "exec",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`command` {String} 要运行的命令，用空格分隔参数 ",
                      "name": "command",
                      "type": "String",
                      "desc": "要运行的命令，用空格分隔参数"
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} 子进程的当前工作目录 ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "子进程的当前工作目录"
                        },
                        {
                          "textRaw": "`env` {Object} 环境变量键值对 ",
                          "name": "env",
                          "type": "Object",
                          "desc": "环境变量键值对"
                        },
                        {
                          "textRaw": "`encoding` {String} （默认: `'utf8'`） ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "（默认: `'utf8'`）"
                        },
                        {
                          "textRaw": "`shell` {String} 用于执行命令的 shell （默认：在 UNIX 上为 `'/bin/sh'`，在 Windows 上为 `'http://nodejs.cn/api/cmd.exe'`。 该 shell 应该能够理解 UNIX 的 `-c` 开关或 Windows 的 `/s /c` 开关。 在 Windows 中，命令行的解析应与 `cmd.exe` 兼容。） ",
                          "name": "shell",
                          "type": "String",
                          "desc": "用于执行命令的 shell （默认：在 UNIX 上为 `'/bin/sh'`，在 Windows 上为 `'http://nodejs.cn/api/cmd.exe'`。 该 shell 应该能够理解 UNIX 的 `-c` 开关或 Windows 的 `/s /c` 开关。 在 Windows 中，命令行的解析应与 `cmd.exe` 兼容。）"
                        },
                        {
                          "textRaw": "`timeout` {Number} （默认: `0`） ",
                          "name": "timeout",
                          "type": "Number",
                          "desc": "（默认: `0`）"
                        },
                        {
                          "textRaw": "[`maxBuffer`] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止。（默认：`200*1024`） ",
                          "name": "[",
                          "desc": "maxBuffer`] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止。（默认：`200*1024`）"
                        },
                        {
                          "textRaw": "`killSignal` {String} （默认: `'SIGTERM'`） ",
                          "name": "killSignal",
                          "type": "String",
                          "desc": "（默认: `'SIGTERM'`）"
                        },
                        {
                          "textRaw": "`uid` {Number} 设置该进程的用户标识。（详见 setuid(2)） ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "设置该进程的用户标识。（详见 setuid(2)）"
                        },
                        {
                          "textRaw": "`gid` {Number} 设置该进程的组标识。（详见 setgid(2)） ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "设置该进程的组标识。（详见 setgid(2)）"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} 当进程终止时调用，并带上输出。 ",
                      "options": [
                        {
                          "textRaw": "`error` {Error} ",
                          "name": "error",
                          "type": "Error"
                        },
                        {
                          "textRaw": "`stdout` {String|Buffer} ",
                          "name": "stdout",
                          "type": "String|Buffer"
                        },
                        {
                          "textRaw": "`stderr` {String|Buffer} ",
                          "name": "stderr",
                          "type": "String|Buffer"
                        }
                      ],
                      "name": "callback",
                      "type": "Function",
                      "desc": "当进程终止时调用，并带上输出。",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {ChildProcess} ",
                      "name": "返回",
                      "type": "ChildProcess"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "command"
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>衍生一个 shell，然后在 shell 中执行 <code>command</code>，且缓冲任何产生的输出。</p>\n<pre><code class=\"lang-js\">const exec = require(&#39;child_process&#39;).exec;\nexec(&#39;cat *.js bad_file | wc -l&#39;, (error, stdout, stderr) =&gt; {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.log(`stderr: ${stderr}`);\n});\n</code></pre>\n<p>如果提供了一个 <code>callback</code> 函数，则它被调用时会带上参数 <code>(error, stdout, stderr)</code>。\n当成功时，<code>error</code> 会是 <code>null</code>。\n当失败时，<code>error</code> 会是一个 <a href=\"errors.html#errors_class_error\"><code>Error</code></a> 实例。\n<code>error.code</code> 属性会是子进程的退出码，<code>error.signal</code> 会被设为终止进程的信号。\n除 <code>0</code> 以外的任何退出码都被认为是一个错误。</p>\n<p>传给回调的 <code>stdout</code> 和 <code>stderr</code> 参数会包含子进程的 stdout 和 stderr 的输出。\n默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。\n<code>encoding</code> 选项可用于指定用于解码 stdout 和 stderr 输出的字符编码。\n如果 <code>encoding</code> 是 <code>&#39;buffer&#39;</code>、或一个无法识别的字符编码，则传入 <code>Buffer</code> 对象到回调函数。</p>\n<p><code>options</code> 参数可以作为第二个参数传入，用于自定义如何衍生进程。\n默认的选项是：</p>\n<pre><code class=\"lang-js\">{\n  encoding: &#39;utf8&#39;,\n  timeout: 0,\n  maxBuffer: 200*1024,\n  killSignal: &#39;SIGTERM&#39;,\n  cwd: null,\n  env: null\n}\n</code></pre>\n<p>如果 <code>timeout</code> 大于 <code>0</code>，当子进程运行超过 <code>timeout</code> 毫秒时，父进程就会发送由 <code>killSignal</code> 属性标识的信号（默认为 <code>&#39;SIGTERM&#39;</code>）。</p>\n<p>注意：不像 POSIX 系统调用中的 exec(3)，<code>child_process.exec()</code> 不会替换现有的进程，且使用一个 shell 来执行命令。</p>\n"
            },
            {
              "textRaw": "child_process.execFile(file[, args][, options][, callback])",
              "type": "method",
              "name": "execFile",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.91"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`file` {String} 要运行的可执行文件的名称或路径 ",
                      "name": "file",
                      "type": "String",
                      "desc": "要运行的可执行文件的名称或路径"
                    },
                    {
                      "textRaw": "`args` {Array} 字符串参数列表 ",
                      "name": "args",
                      "type": "Array",
                      "desc": "字符串参数列表",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} 子进程的当前工作目录 ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "子进程的当前工作目录"
                        },
                        {
                          "textRaw": "`env` {Object} 环境变量键值对 ",
                          "name": "env",
                          "type": "Object",
                          "desc": "环境变量键值对"
                        },
                        {
                          "textRaw": "`encoding` {String} （默认: `'utf8'`） ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "（默认: `'utf8'`）"
                        },
                        {
                          "textRaw": "`timeout` {Number} （默认: `0`） ",
                          "name": "timeout",
                          "type": "Number",
                          "desc": "（默认: `0`）"
                        },
                        {
                          "textRaw": "[`maxBuffer`] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止。（默认：`200*1024`） ",
                          "name": "[",
                          "desc": "maxBuffer`] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止。（默认：`200*1024`）"
                        },
                        {
                          "textRaw": "`killSignal` {String} （默认: `'SIGTERM'`） ",
                          "name": "killSignal",
                          "type": "String",
                          "desc": "（默认: `'SIGTERM'`）"
                        },
                        {
                          "textRaw": "`uid` {Number} 设置该进程的用户标识。（详见 setuid(2)） ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "设置该进程的用户标识。（详见 setuid(2)）"
                        },
                        {
                          "textRaw": "`gid` {Number} 设置该进程的组标识。（详见 setgid(2)） ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "设置该进程的组标识。（详见 setgid(2)）"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} 当进程终止时调用，并带上输出。 ",
                      "options": [
                        {
                          "textRaw": "`error` {Error} ",
                          "name": "error",
                          "type": "Error"
                        },
                        {
                          "textRaw": "`stdout` {String|Buffer} ",
                          "name": "stdout",
                          "type": "String|Buffer"
                        },
                        {
                          "textRaw": "`stderr` {String|Buffer} ",
                          "name": "stderr",
                          "type": "String|Buffer"
                        }
                      ],
                      "name": "callback",
                      "type": "Function",
                      "desc": "当进程终止时调用，并带上输出。",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {ChildProcess} ",
                      "name": "返回",
                      "type": "ChildProcess"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "file"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p><code>child_process.execFile()</code> 函数类似 <a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a>，除了不衍生一个 shell。\n而是，指定的可执行的 <code>file</code> 被直接衍生为一个新进程，这使得它比 <a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 更高效。</p>\n<p>它支持和 <a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 一样的选项。\n由于没有衍生 shell，因此不支持像 I/O 重定向和文件查找这样的行为。</p>\n<pre><code class=\"lang-js\">const execFile = require(&#39;child_process&#39;).execFile;\nconst child = execFile(&#39;node&#39;, [&#39;--version&#39;], (error, stdout, stderr) =&gt; {\n  if (error) {\n    throw error;\n  }\n  console.log(stdout);\n});\n</code></pre>\n<p>传给回调的 <code>stdout</code> 和 <code>stderr</code> 参数会包含子进程的 stdout 和 stderr 的输出。\n默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。\n<code>encoding</code> 选项可用于指定用于解码 stdout 和 stderr 输出的字符编码。\n如果 <code>encoding</code> 是 <code>&#39;buffer&#39;</code>、或一个无法识别的字符编码，则传入 <code>Buffer</code> 对象到回调函数。</p>\n"
            },
            {
              "textRaw": "child_process.fork(modulePath[, args][, options])",
              "type": "method",
              "name": "fork",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`modulePath` {String} 要在子进程中运行的模块 ",
                      "name": "modulePath",
                      "type": "String",
                      "desc": "要在子进程中运行的模块"
                    },
                    {
                      "textRaw": "`args` {Array} 字符串参数列表 ",
                      "name": "args",
                      "type": "Array",
                      "desc": "字符串参数列表",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} 子进程的当前工作目录 ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "子进程的当前工作目录"
                        },
                        {
                          "textRaw": "`env` {Object} 环境变量键值对 ",
                          "name": "env",
                          "type": "Object",
                          "desc": "环境变量键值对"
                        },
                        {
                          "textRaw": "`execPath` {String} 用来创建子进程的执行路径 ",
                          "name": "execPath",
                          "type": "String",
                          "desc": "用来创建子进程的执行路径"
                        },
                        {
                          "textRaw": "`execArgv` {Array} 要传给执行路径的字符串参数列表 （默认: `process.execArgv`） ",
                          "name": "execArgv",
                          "type": "Array",
                          "desc": "要传给执行路径的字符串参数列表 （默认: `process.execArgv`）"
                        },
                        {
                          "textRaw": "`silent` {Boolean} 如果为 `true`，则子进程中的 stdin、 stdout 和 stderr 会被导流到父进程中，否则它们会继承自父进程，详见 [`child_process.spawn()`] 的 [`stdio`] 中的 `'pipe'` 和 `'inherit'` 选项。 （默认: `false`） ",
                          "name": "silent",
                          "type": "Boolean",
                          "desc": "如果为 `true`，则子进程中的 stdin、 stdout 和 stderr 会被导流到父进程中，否则它们会继承自父进程，详见 [`child_process.spawn()`] 的 [`stdio`] 中的 `'pipe'` 和 `'inherit'` 选项。 （默认: `false`）"
                        },
                        {
                          "textRaw": "`stdio` {Array} 支持 [`child_process.spawn()`] 的 [`stdio`] 选项的数组版本。 当提供了该选项，则它会覆盖 `silent`。 该数组必须包含一个值为 `'ipc'` 的子项，否则会抛出错误。 例如 `[0, 1, 2, 'ipc']`。 ",
                          "name": "stdio",
                          "type": "Array",
                          "desc": "支持 [`child_process.spawn()`] 的 [`stdio`] 选项的数组版本。 当提供了该选项，则它会覆盖 `silent`。 该数组必须包含一个值为 `'ipc'` 的子项，否则会抛出错误。 例如 `[0, 1, 2, 'ipc']`。"
                        },
                        {
                          "textRaw": "`uid` {Number} 设置该进程的用户标识。（详见 setuid(2)） ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "设置该进程的用户标识。（详见 setuid(2)）"
                        },
                        {
                          "textRaw": "`gid` {Number} 设置该进程的组标识。（详见 setgid(2)） ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "设置该进程的组标识。（详见 setgid(2)）"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {ChildProcess} ",
                      "name": "返回",
                      "type": "ChildProcess"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "modulePath"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p><code>child_process.fork()</code> 方法是 <a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a> 的一个特殊情况，专门用于衍生新的 Node.js 进程。\n跟 <a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a> 一样返回一个 <a href=\"#child_process_child_process\"><code>ChildProcess</code></a> 对象。\n返回的 <a href=\"#child_process_child_process\"><code>ChildProcess</code></a> 会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。\n详见 <a href=\"#child_process_child_send_message_sendhandle_options_callback\"><code>child.send()</code></a>。</p>\n<p>衍生的 Node.js 子进程与两者之间建立的 IPC 通信信道的异常是独立于父进程的。\n每个进程都有自己的内存，使用自己的 V8 实例。\n由于需要额外的资源分配，因此不推荐衍生大量的 Node.js 进程。</p>\n<p>默认情况下，<code>child_process.fork()</code> 会使用父进程中的 <a href=\"process.html#process_process_execpath\"><code>process.execPath</code></a> 衍生新的 Node.js 实例。\n<code>options</code> 对象中的 <code>execPath</code> 属性可以替换要使用的执行路径。</p>\n<p>使用自定义的 <code>execPath</code> 启动的 Node.js 进程，会使用子进程的环境变量 <code>NODE_CHANNEL_FD</code> 中指定的文件描述符（fd）与父进程通信。\nfd 上的输入和输出期望被分割成一行一行的 JSON 对象。</p>\n<p>注意，不像 POSIX 系统回调中的 fork(2)，<code>child_process.fork()</code> 不会克隆当前进程。</p>\n"
            },
            {
              "textRaw": "child_process.spawn(command[, args][, options])",
              "type": "method",
              "name": "spawn",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`command` {String} 要运行的命令 ",
                      "name": "command",
                      "type": "String",
                      "desc": "要运行的命令"
                    },
                    {
                      "textRaw": "`args` {Array} 字符串参数列表 ",
                      "name": "args",
                      "type": "Array",
                      "desc": "字符串参数列表",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} 子进程的当前工作目录 ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "子进程的当前工作目录"
                        },
                        {
                          "textRaw": "`env` {Object} 环境变量键值对 ",
                          "name": "env",
                          "type": "Object",
                          "desc": "环境变量键值对"
                        },
                        {
                          "textRaw": "`argv0` {String} 显式地设置要发给子进程的 `argv[0]` 的值。 如果未指定，则设为 `command`。 ",
                          "name": "argv0",
                          "type": "String",
                          "desc": "显式地设置要发给子进程的 `argv[0]` 的值。 如果未指定，则设为 `command`。"
                        },
                        {
                          "textRaw": "`stdio` {Array|String} 子进程的 stdio 配置。 （详见 [`options.stdio`]） ",
                          "name": "stdio",
                          "type": "Array|String",
                          "desc": "子进程的 stdio 配置。 （详见 [`options.stdio`]）"
                        },
                        {
                          "textRaw": "`detached` {Boolean} 准备将子进程独立于父进程运行。 具体行为取决于平台。（详见 [`options.detached`]） ",
                          "name": "detached",
                          "type": "Boolean",
                          "desc": "准备将子进程独立于父进程运行。 具体行为取决于平台。（详见 [`options.detached`]）"
                        },
                        {
                          "textRaw": "`uid` {Number} 设置该进程的用户标识。（详见 setuid(2)） ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "设置该进程的用户标识。（详见 setuid(2)）"
                        },
                        {
                          "textRaw": "`gid` {Number} 设置该进程的组标识。（详见 setgid(2)） ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "设置该进程的组标识。（详见 setgid(2)）"
                        },
                        {
                          "textRaw": "`shell` {Boolean|String} 如果为 `true`，则在一个 shell 中运行 `command`。 在 UNIX 上使用 `'/bin/sh'`，在 Windows 上使用 `'http://nodejs.cn/api/cmd.exe'`。 一个不同的 shell 可以被指定为字符串。 该 shell 应该理解 UNIX 上的 `-c` 开关、或 Windows 的 `/s /c`。 默认为 `false`（没有 shell）。 ",
                          "name": "shell",
                          "type": "Boolean|String",
                          "desc": "如果为 `true`，则在一个 shell 中运行 `command`。 在 UNIX 上使用 `'/bin/sh'`，在 Windows 上使用 `'http://nodejs.cn/api/cmd.exe'`。 一个不同的 shell 可以被指定为字符串。 该 shell 应该理解 UNIX 上的 `-c` 开关、或 Windows 的 `/s /c`。 默认为 `false`（没有 shell）。"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {ChildProcess} ",
                      "name": "返回",
                      "type": "ChildProcess"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "command"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p><code>child_process.spawn()</code> 方法使用给定的 <code>command</code> 和 <code>args</code> 中的命令行参数来衍生一个新进程。\n如果省略 <code>args</code>，则默认为一个空数组。</p>\n<p>第三个参数可以用来指定额外的选项，默认如下：</p>\n<pre><code class=\"lang-js\">{\n  cwd: undefined,\n  env: process.env\n}\n</code></pre>\n<p>使用 <code>cwd</code> 来指定衍生的进程的工作目录。\n如果没有给出，则默认继承当前的工作目录。</p>\n<p>使用 <code>env</code> 来指定环境变量，这会在新进程中可见，默认为 <a href=\"process.html#process_process_env\"><code>process.env</code></a>。</p>\n<p>例子，运行 <code>ls -lh /usr</code>，捕获 <code>stdout</code>、<code>stderr</code>、以及退出码：</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst ls = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]);\n\nls.stdout.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`stdout: ${data}`);\n});\n\nls.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`stderr: ${data}`);\n});\n\nls.on(&#39;close&#39;, (code) =&gt; {\n  console.log(`子进程退出码：${code}`);\n});\n</code></pre>\n<p>例子，一种执行 <code>&#39;ps ax | grep ssh&#39;</code> 的方法：</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst ps = spawn(&#39;ps&#39;, [&#39;ax&#39;]);\nconst grep = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\n\nps.stdout.on(&#39;data&#39;, (data) =&gt; {\n  grep.stdin.write(data);\n});\n\nps.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`ps stderr: ${data}`);\n});\n\nps.on(&#39;close&#39;, (code) =&gt; {\n  if (code !== 0) {\n    console.log(`ps 进程退出码：${code}`);\n  }\n  grep.stdin.end();\n});\n\ngrep.stdout.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`${data}`);\n});\n\ngrep.stderr.on(&#39;data&#39;, (data) =&gt; {\n  console.log(`grep stderr: ${data}`);\n});\n\ngrep.on(&#39;close&#39;, (code) =&gt; {\n  if (code !== 0) {\n    console.log(`grep 进程退出码：${code}`);\n  }\n});\n</code></pre>\n<p>例子，检测失败的执行：</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst child = spawn(&#39;bad_command&#39;);\n\nchild.on(&#39;error&#39;, (err) =&gt; {\n  console.log(&#39;启动子进程失败。&#39;);\n});\n</code></pre>\n<p>注意：某些平台（OS X, Linux）会使用 <code>argv[0]</code> 的值作为进程的标题，而其他平台（Windows, SunOS）则使用 <code>command</code>。</p>\n<p>注意，Node.js 一般会在启动时用 <code>process.execPath</code> 重写 <code>argv[0]</code>，所以 Node.js 子进程中的 <code>process.argv[0]</code> 不会匹配从父进程传给 <code>spawn</code> 的 <code>argv0</code> 参数，可以使用 <code>process.argv0</code> 属性获取它。</p>\n",
              "properties": [
                {
                  "textRaw": "options.detached",
                  "name": "detached",
                  "meta": {
                    "added": [
                      "http://nodejs.cn/api/v0.7.10"
                    ]
                  },
                  "desc": "<p>在 Windows 上，设置 <code>options.detached</code> 为 <code>true</code> 可以使子进程在父进程退出后继续运行。\n子进程有自己的控制台窗口。\n一旦启用一个子进程，它将不能被禁用。</p>\n<p>在非 Windows 平台上，如果将 <code>options.detached</code> 设为 <code>true</code>，则子进程会成为新的进程组和会话的领导者。\n注意，子进程在父进程退出后可以继续运行，不管它们是否被分离。\n详见 setsid(2)。</p>\n<p>默认情况下，父进程会等待被分离的子进程退出。\n为了防止父进程等待给定的 <code>child</code>，可以使用 <code>child.unref()</code> 方法。\n这样做会导致父进程的事件循环不包含子进程的引用计数，使得父进程独立于子进程退出，除非子进程和父进程之间建立了一个 IPC 信道。</p>\n<p>当使用 <code>detached</code> 选项来启动一个长期运行的进程时，该进程不会在父进程退出后保持在后台运行，除非提供了一个不连接到父进程的 <code>stdio</code> 配置。\n如果父进程的 <code>stdio</code> 是继承的，则子进程会保持连接到控制终端。</p>\n<p>例子，一个长期运行的进程，为了忽视父进程的终止，通过分离且忽视其父进程的 <code>stdio</code> 文件描述符来实现：</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\n\nconst child = spawn(process.argv[0], [&#39;child_program.js&#39;], {\n  detached: true,\n  stdio: &#39;ignore&#39;\n});\n\nchild.unref();\n</code></pre>\n<p>也可以将子进程的输出重定向到文件：</p>\n<pre><code class=\"lang-js\">const fs = require(&#39;fs&#39;);\nconst spawn = require(&#39;child_process&#39;).spawn;\nconst out = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;);\nconst err = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;);\n\nconst child = spawn(&#39;prg&#39;, [], {\n detached: true,\n stdio: [ &#39;ignore&#39;, out, err ]\n});\n\nchild.unref();\n</code></pre>\n"
                },
                {
                  "textRaw": "options.stdio",
                  "name": "stdio",
                  "meta": {
                    "added": [
                      "http://nodejs.cn/api/v0.7.10"
                    ]
                  },
                  "desc": "<p><code>options.stdio</code> 选项用于配置子进程与父进程之间建立的管道。\n默认情况下，子进程的 stdin、 stdout 和 stderr 会重定向到 <a href=\"#child_process_child_process\"><code>ChildProcess</code></a> 对象上相应的 <a href=\"#child_process_child_stdin\"><code>child.stdin</code></a>、 <a href=\"#child_process_child_stdout\"><code>child.stdout</code></a> 和 <a href=\"#child_process_child_stderr\"><code>child.stderr</code></a> 流。\n这等同于将 <code>options.stdio</code> 设为 <code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code>。</p>\n<p>为了方便起见，<code>options.stdio</code> 可以是以下字符串之一：</p>\n<ul>\n<li><code>&#39;pipe&#39;</code> - 等同于 <code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code> （默认）</li>\n<li><code>&#39;ignore&#39;</code> - 等同于 <code>[&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;]</code></li>\n<li><code>&#39;inherit&#39;</code> - 等同于 <code>[process.stdin, process.stdout, process.stderr]</code> 或 <code>[0,1,2]</code></li>\n</ul>\n<p>另外，<code>option.stdio</code> 的值是一个每个索引都对应一个子进程 fd 的数组。\nfd 的 0、1 和 2 分别对应 stdin、stdout 和 stderr。\n额外的 fd 可以被指定来创建父进程和子进程之间的额外管道。\n该值是以下之一：</p>\n<ol>\n<li><code>&#39;pipe&#39;</code> - 创建一个子进程和父进程之间的管道。\n 在管道的父端以 <a href=\"#child_process_options_stdio\"><code>child.stdio[fd]</code></a> 的形式作为 <code>child_process</code> 对象的一个属性暴露给父进程。\n 为 fd 创建的管道 0 - 2 也可分别作为 <a href=\"#child_process_child_stdin\"><code>child.stdin</code></a>、<a href=\"#child_process_child_stdout\"><code>child.stdout</code></a> 和 <a href=\"#child_process_child_stderr\"><code>child.stderr</code></a>。</li>\n<li><code>&#39;ipc&#39;</code> - 创建一个用于父进程和子进程之间传递消息或文件描述符的 IPC 通道符。\n 一个 <a href=\"#child_process_child_process\"><code>ChildProcess</code></a> 最多只能有一个 IPC stdio 文件描述符。\n 设置该选项可启用 <a href=\"#child_process_child_send_message_sendhandle_options_callback\"><code>child.send()</code></a> 方法。\n 如果子进程把 JSON 消息写入到该文件描述符，则 <a href=\"#child_process_event_message\"><code>child.on(&#39;message&#39;)</code></a> 事件句柄会被父进程触发。\n 如果子进程是一个 Node.js 进程，则一个已存在的 IPC 通道会在子进程中启用 <a href=\"process.html#process_process_send_message_sendhandle_options_callback\"><code>process.send()</code></a>、<a href=\"process.html#process_process_disconnect\"><code>process.disconnect()</code></a>、<a href=\"process.html#process_event_disconnect\"><code>process.on(&#39;disconnect&#39;)</code></a> 和 <a href=\"process.html#process_event_message\"><code>process.on(&#39;message&#39;)</code></a>。</li>\n<li><code>&#39;ignore&#39;</code> - 指示 Node.js 在子进程中忽略 fd。\n 由于 Node.js 总是会为它衍生的进程打开 fd 0 - 2，所以设置 fd 为 <code>&#39;ignore&#39;</code> 可以使 Node.js 打开 <code>/dev/null</code> 并将它附加到子进程的 fd 上。</li>\n<li>{Stream} 对象 - 共享一个指向子进程的 tty、文件、socket 或管道的可读或可写流。\n 流的底层文件描述符在子进程中是重复对应该 <code>stdio</code> 数组的索引的 fd。\n 注意，该流必须有一个底层描述符（文件流直到 <code>&#39;open&#39;</code> 事件发生才需要）。</li>\n<li>正整数 - 整数值被解析为一个正在父进程中打开的文件描述符。\n 它和子进程共享，类似于 {Stream} 是如何被共享的。</li>\n<li><code>null</code>, <code>undefined</code> - 使用默认值。\n 对于 stdio fd 0、1 和 2（换言之，stdin、stdout 和 stderr）而言是创建了一个管道。\n 对于 fd 3 及以上而言，默认值为 <code>&#39;ignore&#39;</code>。</li>\n</ol>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\n\n// 子进程使用父进程的 stdios\nspawn(&#39;prg&#39;, [], { stdio: &#39;inherit&#39; });\n\n// 衍生的子进程只共享 stderr\nspawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, &#39;pipe&#39;, process.stderr] });\n\n// 打开一个额外的 fd=4，用于与程序交互\nspawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, null, null, null, &#39;pipe&#39;] });\n</code></pre>\n<p>注意，当在父进程和子进程之间建立了一个 IPC 通道，且子进程是一个 Node.js 进程，则子进程会带着未引用的 IPC 通道（使用 <code>unref()</code>）启动，直到子进程为 <a href=\"process.html#process_event_disconnect\"><code>process.on(&#39;disconnect&#39;)</code></a> 事件注册了一个事件句柄。\n这使得子进程可以在进程没有通过打开的 IPC 通道保持打开的情况下正常退出。</p>\n<p>详见 <a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 和 <a href=\"#child_process_child_process_fork_modulepath_args_options\"><code>child_process.fork()</code></a>。</p>\n"
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "Asynchronous Process Creation"
        },
        {
          "textRaw": "Synchronous Process Creation",
          "name": "synchronous_process_creation",
          "desc": "<p><a href=\"#child_process_child_process_spawnsync_command_args_options\"><code>child_process.spawnSync()</code></a>、<a href=\"#child_process_child_process_execsync_command_options\"><code>child_process.execSync()</code></a> 和 <a href=\"#child_process_child_process_execfilesync_file_args_options\"><code>child_process.execFileSync()</code></a> 方法是<strong>同步的</strong>且<strong>会</strong>阻塞 Node.js 的事件循环，暂停任何额外代码的执行直到衍生的进程退出。</p>\n<p>像这样的阻塞调用有利于简化普通用途的脚本任务，且启动时有利于简化应用配置的加载/处理。</p>\n",
          "methods": [
            {
              "textRaw": "child_process.execFileSync(file[, args][, options])",
              "type": "method",
              "name": "execFileSync",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.12"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`file` {String} 要运行的可执行文件的名称或路径 ",
                      "name": "file",
                      "type": "String",
                      "desc": "要运行的可执行文件的名称或路径"
                    },
                    {
                      "textRaw": "`args` {Array} 字符串参数列表 ",
                      "name": "args",
                      "type": "Array",
                      "desc": "字符串参数列表",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} 子进程的当前工作目录 ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "子进程的当前工作目录"
                        },
                        {
                          "textRaw": "`input` {String|Buffer} 要作为 stdin 传给衍生进程的值 ",
                          "options": [
                            {
                              "textRaw": "提供该值会覆盖 `stdio[0]` ",
                              "name": "提供该值会覆盖",
                              "desc": "`stdio[0]`"
                            }
                          ],
                          "name": "input",
                          "type": "String|Buffer",
                          "desc": "要作为 stdin 传给衍生进程的值"
                        },
                        {
                          "textRaw": "`stdio` {String | Array} 子进程的 stdio 配置。（默认: `'pipe'`） ",
                          "options": [
                            {
                              "textRaw": "`stderr` 默认会输出到父进程中的 stderr，除非指定了 `stdio` ",
                              "name": "stderr",
                              "desc": "默认会输出到父进程中的 stderr，除非指定了 `stdio`"
                            }
                          ],
                          "name": "stdio",
                          "type": "String | Array",
                          "desc": "子进程的 stdio 配置。（默认: `'pipe'`）"
                        },
                        {
                          "textRaw": "`env` {Object} 环境变量键值对 ",
                          "name": "env",
                          "type": "Object",
                          "desc": "环境变量键值对"
                        },
                        {
                          "textRaw": "`uid` {Number} 设置该进程的用户标识。（详见 setuid(2)） ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "设置该进程的用户标识。（详见 setuid(2)）"
                        },
                        {
                          "textRaw": "`gid` {Number} 设置该进程的组标识。（详见 setgid(2)） ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "设置该进程的组标识。（详见 setgid(2)）"
                        },
                        {
                          "textRaw": "`timeout` {Number} 进程允许运行的最大时间数，以毫秒为单位。（默认: `undefined`） ",
                          "name": "timeout",
                          "type": "Number",
                          "desc": "进程允许运行的最大时间数，以毫秒为单位。（默认: `undefined`）"
                        },
                        {
                          "textRaw": "`killSignal` {String} 当衍生进程将被杀死时要使用的信号值。（默认: `'SIGTERM'`） ",
                          "name": "killSignal",
                          "type": "String",
                          "desc": "当衍生进程将被杀死时要使用的信号值。（默认: `'SIGTERM'`）"
                        },
                        {
                          "textRaw": "[`maxBuffer`] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止 ",
                          "name": "[",
                          "desc": "maxBuffer`] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止"
                        },
                        {
                          "textRaw": "`encoding` {String} 用于所有 stdio 输入和输出的编码。（默认: `'buffer'`） ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "用于所有 stdio 输入和输出的编码。（默认: `'buffer'`）"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Buffer|String} 该命令的 stdout ",
                      "name": "返回",
                      "type": "Buffer|String",
                      "desc": "该命令的 stdout"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "file"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p><code>child_process.execFileSync()</code> 方法与 <a href=\"#child_process_child_process_execfile_file_args_options_callback\"><code>child_process.execFile()</code></a> 基本相同，除了该方法直到子进程完全关闭后才返回。\n当遇到超时且发送了 <code>killSignal</code> 时，则该方法直到进程完全退出后才返回结果。\n注意，如果子进程拦截并处理了 <code>SIGTERM</code> 信号且没有退出，则父进程会一直等待直到子进程退出。</p>\n<p>如果进程超时，或有一个非零的退出码，则该方法会抛出错误。\n<a href=\"errors.html#errors_class_error\"><code>Error</code></a> 对象会包含从 <a href=\"#child_process_child_process_spawnsync_command_args_options\"><code>child_process.spawnSync()</code></a> 返回的整个结果。</p>\n"
            },
            {
              "textRaw": "child_process.execSync(command[, options])",
              "type": "method",
              "name": "execSync",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.12"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`command` {String} 要运行的命令 ",
                      "name": "command",
                      "type": "String",
                      "desc": "要运行的命令"
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} 子进程的当前工作目录 ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "子进程的当前工作目录"
                        },
                        {
                          "textRaw": "`input` {String|Buffer} 要作为 stdin 传给衍生进程的值 ",
                          "options": [
                            {
                              "textRaw": "提供该值会覆盖 `stdio[0]` ",
                              "name": "提供该值会覆盖",
                              "desc": "`stdio[0]`"
                            }
                          ],
                          "name": "input",
                          "type": "String|Buffer",
                          "desc": "要作为 stdin 传给衍生进程的值"
                        },
                        {
                          "textRaw": "`stdio` {String | Array} 子进程的 stdio 配置。（默认: `'pipe'`） ",
                          "options": [
                            {
                              "textRaw": "`stderr` 默认会输出到父进程中的 stderr，除非指定了 `stdio` ",
                              "name": "stderr",
                              "desc": "默认会输出到父进程中的 stderr，除非指定了 `stdio`"
                            }
                          ],
                          "name": "stdio",
                          "type": "String | Array",
                          "desc": "子进程的 stdio 配置。（默认: `'pipe'`）"
                        },
                        {
                          "textRaw": "`env` {Object} 环境变量键值对 ",
                          "name": "env",
                          "type": "Object",
                          "desc": "环境变量键值对"
                        },
                        {
                          "textRaw": "`shell` {String} 用于执行命令的 shell （默认：在 UNIX 上为 `'/bin/sh'`，在 Windows 上为 `'http://nodejs.cn/api/cmd.exe'`。 该 shell 应该能够理解 UNIX 的 `-c` 开关或 Windows 的 `/s /c` 开关。 在 Windows 中，命令行的解析应与 `cmd.exe` 兼容。） ",
                          "name": "shell",
                          "type": "String",
                          "desc": "用于执行命令的 shell （默认：在 UNIX 上为 `'/bin/sh'`，在 Windows 上为 `'http://nodejs.cn/api/cmd.exe'`。 该 shell 应该能够理解 UNIX 的 `-c` 开关或 Windows 的 `/s /c` 开关。 在 Windows 中，命令行的解析应与 `cmd.exe` 兼容。）"
                        },
                        {
                          "textRaw": "`uid` {Number} 设置该进程的用户标识。（详见 setuid(2)） ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "设置该进程的用户标识。（详见 setuid(2)）"
                        },
                        {
                          "textRaw": "`gid` {Number} 设置该进程的组标识。（详见 setgid(2)） ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "设置该进程的组标识。（详见 setgid(2)）"
                        },
                        {
                          "textRaw": "`timeout` {Number} 进程允许运行的最大时间数，以毫秒为单位。（默认: `undefined`） ",
                          "name": "timeout",
                          "type": "Number",
                          "desc": "进程允许运行的最大时间数，以毫秒为单位。（默认: `undefined`）"
                        },
                        {
                          "textRaw": "`killSignal` {String} 当衍生进程将被杀死时要使用的信号值。（默认: `'SIGTERM'`） ",
                          "name": "killSignal",
                          "type": "String",
                          "desc": "当衍生进程将被杀死时要使用的信号值。（默认: `'SIGTERM'`）"
                        },
                        {
                          "textRaw": "[`maxBuffer`][] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止 ",
                          "name": "[",
                          "desc": "maxBuffer`][] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止"
                        },
                        {
                          "textRaw": "`encoding` {String} 用于所有 stdio 输入和输出的编码。（默认: `'buffer'`） ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "用于所有 stdio 输入和输出的编码。（默认: `'buffer'`）"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Buffer|String} 该命令的 stdout ",
                      "name": "返回",
                      "type": "Buffer|String",
                      "desc": "该命令的 stdout"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "command"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p><code>child_process.execSync()</code> 方法与 <a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a> 基本相同，除了该方法直到子进程完全关闭后才返回。\n当遇到超时且发送了 <code>killSignal</code> 时，则该方法直到进程完全退出后才返回结果。\n注意，如果子进程拦截并处理了 <code>SIGTERM</code> 信号且没有退出，则父进程会一直等待直到子进程退出。</p>\n<p>如果进程超时，或有一个非零的退出码，则该方法会抛出错误。\n<a href=\"errors.html#errors_class_error\"><code>Error</code></a> 对象会包含从 <a href=\"#child_process_child_process_spawnsync_command_args_options\"><code>child_process.spawnSync()</code></a> 返回的整个结果。</p>\n"
            },
            {
              "textRaw": "child_process.spawnSync(command[, args][, options])",
              "type": "method",
              "name": "spawnSync",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.11.12"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`command` {String} 要运行的命令 ",
                      "name": "command",
                      "type": "String",
                      "desc": "要运行的命令"
                    },
                    {
                      "textRaw": "`args` {Array} 字符串参数列表 ",
                      "name": "args",
                      "type": "Array",
                      "desc": "字符串参数列表",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`cwd` {String} 子进程的当前工作目录 ",
                          "name": "cwd",
                          "type": "String",
                          "desc": "子进程的当前工作目录"
                        },
                        {
                          "textRaw": "`input` {String|Buffer} 要作为 stdin 传给衍生进程的值 ",
                          "options": [
                            {
                              "textRaw": "提供该值会覆盖 `stdio[0]` ",
                              "name": "提供该值会覆盖",
                              "desc": "`stdio[0]`"
                            }
                          ],
                          "name": "input",
                          "type": "String|Buffer",
                          "desc": "要作为 stdin 传给衍生进程的值"
                        },
                        {
                          "textRaw": "`stdio` {String | Array} 子进程的 stdio 配置 ",
                          "name": "stdio",
                          "type": "String | Array",
                          "desc": "子进程的 stdio 配置"
                        },
                        {
                          "textRaw": "`env` {Object} 环境变量键值对 ",
                          "name": "env",
                          "type": "Object",
                          "desc": "环境变量键值对"
                        },
                        {
                          "textRaw": "`uid` {Number} 设置该进程的用户标识。（详见 setuid(2)） ",
                          "name": "uid",
                          "type": "Number",
                          "desc": "设置该进程的用户标识。（详见 setuid(2)）"
                        },
                        {
                          "textRaw": "`gid` {Number} 设置该进程的组标识。（详见 setgid(2)） ",
                          "name": "gid",
                          "type": "Number",
                          "desc": "设置该进程的组标识。（详见 setgid(2)）"
                        },
                        {
                          "textRaw": "`timeout` {Number} 进程允许运行的最大时间数，以毫秒为单位。（默认: `undefined`） ",
                          "name": "timeout",
                          "type": "Number",
                          "desc": "进程允许运行的最大时间数，以毫秒为单位。（默认: `undefined`）"
                        },
                        {
                          "textRaw": "`killSignal` {String} 当衍生进程将被杀死时要使用的信号值。（默认: `'SIGTERM'`） ",
                          "name": "killSignal",
                          "type": "String",
                          "desc": "当衍生进程将被杀死时要使用的信号值。（默认: `'SIGTERM'`）"
                        },
                        {
                          "textRaw": "[`maxBuffer`][] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止 ",
                          "name": "[",
                          "desc": "maxBuffer`][] {Number} stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止"
                        },
                        {
                          "textRaw": "`encoding` {String} 用于所有 stdio 输入和输出的编码。（默认: `'buffer'`） ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "用于所有 stdio 输入和输出的编码。（默认: `'buffer'`）"
                        },
                        {
                          "textRaw": "`shell` {Boolean|String} 如果为 `true`，则在一个 shell 中运行 `command`。 在 UNIX 上使用 `'/bin/sh'`，在 Windows 上使用 `'http://nodejs.cn/api/cmd.exe'`。 一个不同的 shell 可以被指定为字符串。 该 shell 应该理解 UNIX 上的 `-c` 开关、或 Windows 的 `/s /c`。 默认为 `false`（没有 shell）。 ",
                          "name": "shell",
                          "type": "Boolean|String",
                          "desc": "如果为 `true`，则在一个 shell 中运行 `command`。 在 UNIX 上使用 `'/bin/sh'`，在 Windows 上使用 `'http://nodejs.cn/api/cmd.exe'`。 一个不同的 shell 可以被指定为字符串。 该 shell 应该理解 UNIX 上的 `-c` 开关、或 Windows 的 `/s /c`。 默认为 `false`（没有 shell）。"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Object} ",
                      "options": [
                        {
                          "textRaw": "`pid` {Number} 子进程的 pid ",
                          "name": "pid",
                          "type": "Number",
                          "desc": "子进程的 pid"
                        },
                        {
                          "textRaw": "`output` {Array} stdio 输出返回的结果数组 ",
                          "name": "output",
                          "type": "Array",
                          "desc": "stdio 输出返回的结果数组"
                        },
                        {
                          "textRaw": "`stdout` {Buffer|String} `output[1]` 的内容  ",
                          "name": "stdout",
                          "type": "Buffer|String",
                          "desc": "`output[1]` 的内容"
                        },
                        {
                          "textRaw": "`stderr` {Buffer|String} `output[2]` 的内容 ",
                          "name": "stderr",
                          "type": "Buffer|String",
                          "desc": "`output[2]` 的内容"
                        },
                        {
                          "textRaw": "`status` {Number} 子进程的退出码 ",
                          "name": "status",
                          "type": "Number",
                          "desc": "子进程的退出码"
                        },
                        {
                          "textRaw": "`signal` {String} 用于杀死子进程的信号 ",
                          "name": "signal",
                          "type": "String",
                          "desc": "用于杀死子进程的信号"
                        },
                        {
                          "textRaw": "`error` {Error} 如果子进程失败或超时产生的错误对象 ",
                          "name": "error",
                          "type": "Error",
                          "desc": "如果子进程失败或超时产生的错误对象"
                        }
                      ],
                      "name": "返回",
                      "type": "Object"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "command"
                    },
                    {
                      "name": "args",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p><code>child_process.spawnSync()</code> 方法与 <a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a> 基本相同，除了该方法直到子进程完全关闭后才返回。\n当遇到超时且发送了 <code>killSignal</code> 时，则该方法直到进程完全退出后才返回结果。\n注意，如果子进程拦截并处理了 <code>SIGTERM</code> 信号且没有退出，则父进程会一直等待直到子进程退出。</p>\n"
            }
          ],
          "type": "module",
          "displayName": "Synchronous Process Creation"
        },
        {
          "textRaw": "`maxBuffer` and Unicode",
          "name": "`maxbuffer`_and_unicode",
          "desc": "<p><code>maxBuffer</code> 选项指定了 <code>stdout</code> 或 <code>stderr</code> 上允许的八位字节的最大数量。\n如果超过这个值，则子进程会被终止。\n这会影响包含多字节字符编码的输出，如 UTF-8 或 UTF-16。\n例如，以下将输出 13 个 UTF-8 编码的八位字节到 <code>stdout</code>，尽管只有 4 个字符：</p>\n<pre><code class=\"lang-js\">console.log(&#39;中文测试&#39;);\n</code></pre>\n",
          "type": "module",
          "displayName": "`maxBuffer` and Unicode"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: ChildProcess",
          "type": "class",
          "name": "ChildProcess",
          "meta": {
            "added": [
              "v2.2.0"
            ]
          },
          "desc": "<p><code>ChildProcess</code> 类的实例是 <a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a>，代表衍生的子进程。</p>\n<p><code>ChildProcess</code> 的实例不被直接创建。\n而是，使用 <a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a>、<a href=\"#child_process_child_process_exec_command_options_callback\"><code>child_process.exec()</code></a>、<a href=\"#child_process_child_process_execfile_file_args_options_callback\"><code>child_process.execFile()</code></a> 或 <a href=\"#child_process_child_process_fork_modulepath_args_options\"><code>child_process.fork()</code></a> 方法创建 <code>ChildProcess</code> 实例。</p>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.7.7"
                ]
              },
              "params": [],
              "desc": "<p>当子进程的 stdio 流被关闭时会触发 <code>&#39;close&#39;</code> 事件。\n这与 <a href=\"#child_process_event_exit\"><code>&#39;exit&#39;</code></a> 事件不同，因为多个进程可能共享同一 stdio 流。</p>\n"
            },
            {
              "textRaw": "Event: 'disconnect'",
              "type": "event",
              "name": "disconnect",
              "meta": {
                "added": [
                  "v0.7.2"
                ]
              },
              "desc": "<p>在父进程中调用 <a href=\"#child_process_child_disconnect\"><code>child.disconnect()</code></a> 或在子进程中调用 <a href=\"process.html#process_process_disconnect\"><code>process.disconnect()</code></a> 后会触发 <code>&#39;disconnect&#39;</code> 事件。\n断开后就不能再发送或接收信息，且 <a href=\"#child_process_child_connected\"><code>child.connected</code></a> 属性会被设为 <code>false</code>。</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<p>每当出现以下情况时触发 <code>&#39;error&#39;</code> 事件：</p>\n<ol>\n<li><p>进程无法被衍生；</p>\n</li>\n<li><p>进程无法被杀死；</p>\n</li>\n<li><p>向子进程发送信息失败。</p>\n</li>\n</ol>\n<p>注意，在错误发生后，<code>&#39;exit&#39;</code> 事件可能会也可能不会触发。\n如果你同时监听了 <code>&#39;exit&#39;</code> 和 <code>&#39;error&#39;</code> 事件，谨防处理函数被多次调用。</p>\n<p>详见 <a href=\"#child_process_child_kill_signal\"><code>child.kill()</code></a> 和 <a href=\"#child_process_child_send_message_sendhandle_options_callback\"><code>child.send()</code></a>。</p>\n"
            },
            {
              "textRaw": "Event: 'exit'",
              "type": "event",
              "name": "exit",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "params": [],
              "desc": "<p>子进程结束后会触发 <code>&#39;exit&#39;</code> 事件。\n如果进程退出了，则 <code>code</code> 是进程的最终退出码，否则为 <code>null</code>。\n如果进程是收到的信号而终止的，则 <code>signal</code> 是信号的字符串名称，否则为 <code>null</code>。\n这两个总有一个是非空的。</p>\n<p>注意，当 <code>&#39;exit&#39;</code> 事件被触发时，子进程的 stdio 流可能依然是打开的。</p>\n<p>另外，还要注意，Node.js 建立了 <code>SIGINT</code> 和 <code>SIGTERM</code> 的信号处理程序，且 Node.js 进程收到这些信号也不会立即终止。\n相反，Node.js 会执行一系列的清理操作后重新引发处理信号。</p>\n<p>详见 waitpid(2)。</p>\n"
            },
            {
              "textRaw": "Event: 'message'",
              "type": "event",
              "name": "message",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "params": [],
              "desc": "<p>当一个子进程使用 <a href=\"process.html#process_process_send_message_sendhandle_options_callback\"><code>process.send()</code></a> 发送消息时会触发 <code>&#39;message&#39;</code> 事件。</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`connected` {Boolean} 调用 `child.disconnect()` 后会被设为 `false` ",
              "type": "Boolean",
              "name": "connected",
              "meta": {
                "added": [
                  "v0.7.2"
                ]
              },
              "desc": "<p><code>child.connected</code> 属性表明是否仍可以从一个子进程发送和接收消息。\n当 <code>child.connected</code> 为 <code>false</code> 时，则不能再发送或接收的消息。</p>\n",
              "shortDesc": "调用 `child.disconnect()` 后会被设为 `false`"
            },
            {
              "textRaw": "`pid` {Number} 整数 ",
              "type": "Number",
              "name": "pid",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "desc": "<p>返回子进程的进程标识（PID）。</p>\n<p>例子：</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst grep = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\n\nconsole.log(`衍生的子进程的 pid：${grep.pid}`);\ngrep.stdin.end();\n</code></pre>\n",
              "shortDesc": "整数"
            },
            {
              "textRaw": "`stderr` {stream.Readable} ",
              "type": "stream.Readable",
              "name": "stderr",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "desc": "<p>一个代表子进程的 <code>stderr</code> 的可读流。</p>\n<p>如果子进程被衍生时 <code>stdio[2]</code> 被设为任何不是 <code>&#39;pipe&#39;</code> 的值，则这会是 <code>undefined</code>。</p>\n<p><code>child.stderr</code> 是 <code>child.stdio[2]</code> 的一个别名。\n这两个属性指向相同的值。</p>\n"
            },
            {
              "textRaw": "`stdin` {stream.Writable} ",
              "type": "stream.Writable",
              "name": "stdin",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "desc": "<p>一个代表子进程的 <code>stdin</code> 的可写流。</p>\n<p>注意，如果一个子进程正在等待读取所有的输入，则子进程不会继续直到流已通过 <code>end()</code> 关闭。</p>\n<p>如果子进程被衍生时 <code>stdio[0]</code> 被设为任何不是 <code>&#39;pipe&#39;</code> 的值，则这会是 <code>undefined</code>。</p>\n<p><code>child.stdin</code> 是 <code>child.stdio[0]</code> 的一个别名。\n这两个属性指向相同的值。</p>\n"
            },
            {
              "textRaw": "`stdio` {Array} ",
              "type": "Array",
              "name": "stdio",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.7.10"
                ]
              },
              "desc": "<p>一个到子进程的管道的稀疏数组，对应着传给 <a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn()</code></a> 的选项中值被设为 <code>&#39;pipe&#39;</code> 的 <a href=\"#child_process_options_stdio\"><code>stdio</code></a>。\n注意，<code>child.stdio[0]</code>、<code>child.stdio[1]</code> 和 <code>child.stdio[2]</code> 分别可用作 <code>child.stdin</code>、 <code>child.stdout</code> 和 <code>child.stderr</code>。</p>\n<p>在下面的例子中，只有子进程的 fd <code>1</code>（stdout）被配置为一个管道，所以只有父进程的 <code>child.stdio[1]</code> 是一个流，数组中的其他值都是 <code>null</code>。</p>\n<pre><code class=\"lang-js\">const assert = require(&#39;assert&#39;);\nconst fs = require(&#39;fs&#39;);\nconst child_process = require(&#39;child_process&#39;);\n\nconst child = child_process.spawn(&#39;ls&#39;, {\n    stdio: [\n      0, // 使用父进程的 stdin 用于子进程\n      &#39;pipe&#39;, // 把子进程的 stdout 通过管道传到父进程 \n      fs.openSync(&#39;err.out&#39;, &#39;w&#39;) // 把子进程的 stderr 指向一个文件\n    ]\n});\n\nassert.equal(child.stdio[0], null);\nassert.equal(child.stdio[0], child.stdin);\n\nassert(child.stdout);\nassert.equal(child.stdio[1], child.stdout);\n\nassert.equal(child.stdio[2], null);\nassert.equal(child.stdio[2], child.stderr);\n</code></pre>\n"
            },
            {
              "textRaw": "`stdout` {stream.Readable} ",
              "type": "stream.Readable",
              "name": "stdout",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "desc": "<p>一个代表子进程的 <code>stdout</code> 的可读流。</p>\n<p>如果子进程被衍生时 <code>stdio[1]</code> 被设为任何不是 <code>&#39;pipe&#39;</code> 的值，则这会是 <code>undefined</code>。</p>\n<p><code>child.stdout</code> 是 <code>child.stdio[1]</code> 的一个别名。\n这两个属性指向相同的值。</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "child.disconnect()",
              "type": "method",
              "name": "disconnect",
              "meta": {
                "added": [
                  "v0.7.2"
                ]
              },
              "desc": "<p>关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。\n调用该方法后，父进程和子进程上各自的 <code>child.connected</code> 和 <code>process.connected</code> 属性都会被设为 <code>false</code>，且进程之间不能再传递消息。</p>\n<p>当正在接收的进程中没有消息时，就会触发 <code>&#39;disconnect&#39;</code> 事件。\n这经常在调用 <code>child.disconnect()</code> 后立即被触发。</p>\n<p>注意，当子进程是一个 Node.js 实例时（例如通过 <a href=\"#child_process_child_process_fork_modulepath_args_options\"><code>child_process.fork()</code></a> 衍生的），可以在子进程内调用 <code>process.disconnect()</code> 方法来关闭 IPC 通道。</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "child.kill([signal])",
              "type": "method",
              "name": "kill",
              "meta": {
                "added": [
                  "http://nodejs.cn/api/v0.1.90"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`signal` {String} ",
                      "name": "signal",
                      "type": "String",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "signal",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p><code>child.kill()</code> 方法向子进程发送一个信号。\n如果没有给定参数，则进程会发送 <code>&#39;SIGTERM&#39;</code> 信号。\n查看 signal(7) 了解可用的信号列表。</p>\n<pre><code class=\"lang-js\">const spawn = require(&#39;child_process&#39;).spawn;\nconst grep = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\n\ngrep.on(&#39;close&#39;, (code, signal) =&gt; {\n  console.log(`子进程收到信号 ${signal} 而终止`);\n});\n\n// 发送 SIGHUP 到进程\ngrep.kill(&#39;SIGHUP&#39;);\n</code></pre>\n<p>如果信号没有被送达，<a href=\"#child_process_child_process\"><code>ChildProcess</code></a> 对象可能会触发一个 <a href=\"#child_process_event_error\"><code>&#39;error&#39;</code></a> 事件。\n向一个已经退出的子进程发送信号不是一个错误，但可能有无法预知的后果。\n特别是，如果进程的 PID 已经重新分配给其他进程，则信号会被发送到该进程，从而可能有意想不到的结果。</p>\n<p>注意，当函数被调用 <code>kill</code> 时，已发送到子进程的信号可能没有实际终止该进程。</p>\n<p>详见 kill(2)。</p>\n<p>注意：在 Linux 上，当试图杀死父进程时，子进程的子进程不会被终止。\n这有可能发生在当在一个 shell 中运行一个新进程时，或使用 <code>ChildProcess</code> 中的 <code>shell</code> 选项时，例如：</p>\n<pre><code class=\"lang-js\">&#39;use strict&#39;;\nconst spawn = require(&#39;child_process&#39;).spawn;\n\nlet child = spawn(&#39;sh&#39;, [&#39;-c&#39;,\n  `node -e &quot;setInterval(() =&gt; {\n      console.log(process.pid, &#39;is alive&#39;)\n    }, 500);&quot;`\n  ], {\n    stdio: [&#39;inherit&#39;, &#39;inherit&#39;, &#39;inherit&#39;]\n  });\n\nsetTimeout(() =&gt; {\n  child.kill(); // 不会终止 shell 中的 node 进程\n}, 2000);\n</code></pre>\n"
            },
            {
              "textRaw": "child.send(message[, sendHandle[, options]][, callback])",
              "type": "method",
              "name": "send",
              "meta": {
                "added": [
                  "v0.5.9"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`message` {Object} ",
                      "name": "message",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`sendHandle` {Handle} ",
                      "name": "sendHandle",
                      "type": "Handle",
                      "optional": true
                    },
                    {
                      "textRaw": "`options` {Object} ",
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    },
                    {
                      "textRaw": "返回: {Boolean} ",
                      "name": "返回",
                      "type": "Boolean"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "sendHandle",
                      "optional": true
                    },
                    {
                      "name": "options",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>当父进程和子进程之间建立了一个 IPC 通道时（例如，使用 <a href=\"#child_process_child_process_fork_modulepath_args_options\"><code>child_process.fork()</code></a>），<code>child.send()</code> 方法可用于发送消息到子进程。\n当子进程是一个 Node.js 实例时，消息可以通过 <a href=\"process.html#process_event_message\"><code>process.on(&#39;message&#39;)</code></a> 事件接收。</p>\n<p>例子，父进程脚本如下：</p>\n<pre><code class=\"lang-js\">const cp = require(&#39;child_process&#39;);\nconst n = cp.fork(`${__dirname}/sub.js`);\n\nn.on(&#39;message&#39;, (m) =&gt; {\n  console.log(&#39;父进程收到消息：&#39;, m);\n});\n\nn.send({ hello: &#39;world&#39; });\n</code></pre>\n<p>然后是子进程脚本，<code>&#39;sub.js&#39;</code> 可能看上去像这样：</p>\n<pre><code class=\"lang-js\">process.on(&#39;message&#39;, (m) =&gt; {\n  console.log(&#39;子进程收到消息：&#39;, m);\n});\n\nprocess.send({ foo: &#39;bar&#39; });\n</code></pre>\n<p>Node.js 中的子进程有一个自己的 <a href=\"process.html#process_process_send_message_sendhandle_options_callback\"><code>process.send()</code></a> 方法，允许子进程发送消息回父进程。</p>\n<p>当发送一个 <code>{cmd: &#39;NODE_foo&#39;}</code> 消息时，是一个特例。\n所有在 <code>cmd</code> 属性里包含一个 <code>NODE_</code> 前缀的都会被认为是预留给 Node.js 核心代码内部使用的，且不会触发子进程的 <a href=\"process.html#process_event_message\"><code>process.on(&#39;message&#39;)</code></a> 事件。\n而是，这种消息可使用 <code>process.on(&#39;internalMessage&#39;)</code> 事件触发，且被 Node.js 内部消费。\n应用程序应避免使用这种消息或监听 <code>&#39;internalMessage&#39;</code> 事件。</p>\n<p>可选的 <code>sendHandle</code> 参数可能被传给 <code>child.send()</code>，它用于传入一个 TCP 服务器或 socket 对象给子进程。\n子进程会接收对象作为第二个参数，并传给注册在 <a href=\"process.html#process_event_message\"><code>process.on(&#39;message&#39;)</code></a> 事件上的回调函数。\nsocket 上接收或缓冲的任何数据不会被发送给子进程。</p>\n<p><code>options</code> 参数，如果存在的话，是一个用于处理发送数据参数对象。<code>options</code> 支持以下属性：</p>\n<ul>\n<li><code>keepOpen</code> - 一个 Boolean 值，当传入 <code>net.Socket</code> 实例时可用。\n当为 <code>true</code> 时，socket 在发送进程中保持打开。\n默认为 <code>false</code>。</li>\n</ul>\n<p>可选的 <code>callback</code> 是一个函数，它在消息发送之后、子进程收到消息之前被调用。\n该函数被调用时只有一个参数：成功时是 <code>null</code>，失败时是一个 <a href=\"errors.html#errors_class_error\"><code>Error</code></a> 对象。</p>\n<p>如果没有提供 <code>callback</code> 函数，且消息没被发送，则一个 <code>&#39;error&#39;</code> 事件将被 <a href=\"#child_process_child_process\"><code>ChildProcess</code></a> 对象触发。\n这是有可能发生的，例如当子进程已经退出时。</p>\n<p>如果通道已关闭，或当未发送的消息的积压超过阈值使其无法发送更多时，<code>child.send()</code> 会返回 <code>false</code>。\n除此以外，该方法返回 <code>true</code>。\n<code>callback</code> 函数可用于实现流量控制。</p>\n<h4>Example: sending a server object</h4>\n<p><code>sendHandle</code> 参数可用于将一个 TCP server 对象句柄传给子进程，如下所示：</p>\n<pre><code class=\"lang-js\">const child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;);\n\n// 开启 server 对象，并发送该句柄。\nconst server = require(&#39;net&#39;).createServer();\nserver.on(&#39;connection&#39;, (socket) =&gt; {\n  socket.end(&#39;被父进程处理&#39;);\n});\nserver.listen(1337, () =&gt; {\n  child.send(&#39;server&#39;, server);\n});\n</code></pre>\n<p>子进程接收 server 对象如下：</p>\n<pre><code class=\"lang-js\">process.on(&#39;message&#39;, (m, server) =&gt; {\n  if (m === &#39;server&#39;) {\n    server.on(&#39;connection&#39;, (socket) =&gt; {\n      socket.end(&#39;被子进程处理&#39;);\n    });\n  }\n});\n</code></pre>\n<p>当服务器在父进程和子进程之间是共享的，则一些连接可被父进程处理，另一些可被子进程处理。</p>\n<p>上面的例子使用了一个 <code>net</code> 模块创建的服务器，而 <code>dgram</code> 模块的服务器使用完全相同的工作流程，但它监听一个 <code>&#39;message&#39;</code> 事件而不是 <code>&#39;connection&#39;</code> 事件，且使用 <code>server.bind</code> 而不是 <code>server.listen()</code>。\n目前仅 UNIX 平台支持这一点。</p>\n<h4>Example: sending a socket object</h4>\n<p>同样，<code>sendHandle</code> 参数可用于将一个 socket 句柄传给子进程。\n以下例子衍生了两个子进程，分别用于处理 &quot;normal&quot; 连接或优先处理 &quot;special&quot; 连接：</p>\n<pre><code class=\"lang-js\">const normal = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;normal&#39;]);\nconst special = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;special&#39;]);\n\n// 开启 server，并发送 socket 给子进程\nconst server = require(&#39;net&#39;).createServer();\nserver.on(&#39;connection&#39;, (socket) =&gt; {\n\n  // 特殊优先级\n  if (socket.remoteAddress === &#39;74.125.127.100&#39;) {\n    special.send(&#39;socket&#39;, socket);\n    return;\n  }\n  // 普通优先级\n  normal.send(&#39;socket&#39;, socket);\n});\nserver.listen(1337);\n</code></pre>\n<p><code>child.js</code> 会接收到一个 socket 句柄，并作为第二个参数传给事件回调函数：</p>\n<pre><code class=\"lang-js\">process.on(&#39;message&#39;, (m, socket) =&gt; {\n  if (m === &#39;socket&#39;) {\n    socket.end(`请求被 ${process.argv[2]} 优先级处理`);\n  }\n});\n</code></pre>\n<p>一旦一个 socket 已被传给了子进程，则父进程不再能够跟踪 socket 何时被销毁。\n为了表明这个，<code>.connections</code> 属性会变成 <code>null</code>。\n当发生这种情况时，建议不要使用 <code>.maxConnections</code>。</p>\n<p>注意，该函数内部使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"><code>JSON.stringify()</code></a> 序列化 <code>message</code>。</p>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Child Process"
    }
  ]
}